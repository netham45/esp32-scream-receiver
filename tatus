[1mdiff --git a/main/audio.c b/main/audio.c[m
[1mindex 5a8a05e..bbb85c0 100644[m
[1m--- a/main/audio.c[m
[1m+++ b/main/audio.c[m
[36m@@ -2,7 +2,9 @@[m
 #include "buffer.h"[m
 #include "freertos/FreeRTOS.h"[m
 #include "freertos/task.h"[m
[32m+[m[32m#include "freertos/event_groups.h"[m
 #include "esp_log.h"[m
[32m+[m[32m#include "esp_timer.h"[m
 #ifdef IS_SPDIF[m
 #include "spdif.h"[m
 #endif[m
[36m@@ -11,78 +13,267 @@[m
 uac_host_device_handle_t spkr_handle = NULL;[m
 #endif[m
 [m
[32m+[m[32m// Audio state variables[m
 bool playing = false;[m
[31m-[m
 uint8_t volume = 100;[m
 uint8_t silence[32] = {0};[m
 bool is_silent = false;[m
[32m+[m[32muint32_t silent_period_count = 0;[m
[32m+[m
[32m+[m[32m// Power management settings[m
[32m+[m[32m#define SILENCE_POWER_REDUCTION_THRESHOLD 100  // Number of silent frames before reducing power[m
[32m+[m[32m#define AUDIO_CHECK_INTERVAL_MS 20             // How often to check for audio activity when idle[m
[32m+[m
[32m+[m[32m// Event group for audio synchronization[m
[32m+[m[32mEventGroupHandle_t audio_event_group = NULL;[m
[32m+[m[32m#define AUDIO_DATA_READY_BIT (1 << 0)[m
[32m+[m[32m#define AUDIO_STOP_BIT (1 << 1)[m
[32m+[m
[32m+[m[32m// Forward declarations for internal functions[m
[32m+[m[32mstatic void audio_task_wakeup(void);[m
[32m+[m[32mstatic void reduce_power_during_silence(bool is_active);[m
 [m
[31m-void resume_playback() {[m
[32m+[m[32mesp_err_t resume_playback() {[m
[32m+[m[32m    esp_err_t err = ESP_OK;[m
[32m+[m[41m    [m
 #ifdef IS_USB[m
[31m-	uac_host_stream_config_t stm_config = {[m
[32m+[m[32m    // Check if we have a valid speaker handle[m
[32m+[m[32m    if (spkr_handle == NULL) {[m
[32m+[m[32m        ESP_LOGW(TAG, "Cannot resume playback - no valid speaker handle");[m
[32m+[m[32m        return ESP_ERR_INVALID_STATE;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    uac_host_stream_config_t stm_config = {[m
         .channels = 2,[m
         .bit_resolution = 16,[m
         .sample_freq = 48000,[m
     };[m
[31m-    ESP_ERROR_CHECK(uac_host_device_start(spkr_handle, &stm_config));[m
[31m-	ESP_ERROR_CHECK(uac_host_device_set_volume(spkr_handle, volume));[m
[32m+[m[41m    [m
[32m+[m[32m    // Start the UAC device and handle errors gracefully[m
[32m+[m[32m    err = uac_host_device_start(spkr_handle, &stm_config);[m
[32m+[m[32m    if (err != ESP_OK) {[m
[32m+[m[32m        ESP_LOGE(TAG, "Failed to start UAC device: %d", err);[m
[32m+[m[32m        return err;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Set volume and handle potential errors[m
[32m+[m[32m    err = uac_host_device_set_volume(spkr_handle, volume);[m
[32m+[m[32m    if (err != ESP_OK) {[m
[32m+[m[32m        ESP_LOGW(TAG, "Failed to set volume: %d", err);[m
[32m+[m[32m        // Continue anyway - volume setting is not critical[m
[32m+[m[32m    }[m
 #endif[m
[31m-	ESP_LOGI(TAG, "Resume Playback");[m
[31m-	playing = true;[m
[32m+[m
[32m+[m[32m    ESP_LOGI(TAG, "Resume Playback");[m
[32m+[m[32m    playing = true;[m
[32m+[m[32m    is_silent = false;[m
[32m+[m[32m    silent_period_count = 0;[m
[32m+[m[41m    [m
[32m+[m[32m    // Ensure we're in active power mode when playback starts[m
[32m+[m[32m    reduce_power_during_silence(true);[m
[32m+[m[41m    [m
[32m+[m[32m    // Signal audio task to wake up if it's sleeping[m
[32m+[m[32m    audio_task_wakeup();[m
[32m+[m[41m    [m
[32m+[m[32m    return ESP_OK;[m
 }[m
 [m
 #ifdef IS_USB[m
[31m-void start_playback(uac_host_device_handle_t _spkr_handle) {[m
[31m-	spkr_handle = _spkr_handle;[m
[32m+[m[32mesp_err_t start_playback(uac_host_device_handle_t _spkr_handle) {[m
[32m+[m[32m    // Validate the handle[m
[32m+[m[32m    if (_spkr_handle == NULL) {[m
[32m+[m[32m        ESP_LOGE(TAG, "Invalid speaker handle");[m
[32m+[m[32m        return ESP_ERR_INVALID_ARG;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    spkr_handle = _spkr_handle;[m
[32m+[m[41m    [m
[32m+[m[32m    // Track the connection in the global state[m
[32m+[m[32m    extern bool g_usb_connected;[m
[32m+[m[32m    g_usb_connected = true;[m
[32m+[m[41m    [m
[32m+[m[32m    // Update activity timestamp in global state[m
[32m+[m[32m    extern uint32_t g_last_audio_activity;[m
[32m+[m[32m    g_last_audio_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[41m    [m
[32m+[m[32m    // Reset silence counter[m
[32m+[m[32m    silent_period_count = 0;[m
[32m+[m[32m    is_silent = false;[m
[32m+[m[41m    [m
[32m+[m[32m    return ESP_OK;[m
 }[m
 #endif[m
 [m
[31m-void stop_playback() {[m
[31m-	playing = false;[m
[31m-	ESP_LOGI(TAG, "Stop Playback");[m
[32m+[m[32mesp_err_t stop_playback() {[m
[32m+[m[32m    playing = false;[m
[32m+[m[32m    ESP_LOGI(TAG, "Stop Playback");[m
[32m+[m[41m    [m
 #ifdef IS_USB[m
[31m-	uac_host_device_stop(spkr_handle);[m
[32m+[m[32m    esp_err_t err = ESP_OK;[m
[32m+[m[41m    [m
[32m+[m[32m    if (spkr_handle != NULL) {[m
[32m+[m[32m        err = uac_host_device_stop(spkr_handle);[m
[32m+[m[32m        if (err != ESP_OK) {[m
[32m+[m[32m            ESP_LOGW(TAG, "Error stopping UAC device: %d", err);[m
[32m+[m[32m            // Continue despite error[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
 #endif[m
[32m+[m[41m    [m
[32m+[m[32m    // Signal audio task to stop processing[m
[32m+[m[32m    if (audio_event_group != NULL) {[m
[32m+[m[32m        xEventGroupSetBits(audio_event_group, AUDIO_STOP_BIT);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    return ESP_OK;[m
 }[m
 [m
[31m-void audio_direct_write(uint8_t *data) {[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Adjust power consumption based on audio activity[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @param is_active True if active audio is being processed[m
[32m+[m[32m */[m
[32m+[m[32mstatic void reduce_power_during_silence(bool is_active) {[m
[32m+[m[32m    // Update global activity timestamp if there's audio activity[m
[32m+[m[32m    if (is_active) {[m
[32m+[m[32m        extern uint32_t g_last_audio_activity;[m
[32m+[m[32m        g_last_audio_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[41m        [m
[32m+[m[32m        // Reset silence counter[m
[32m+[m[32m        silent_period_count = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Wake up the audio processing task[m
[32m+[m[32m */[m
[32m+[m[32mstatic void audio_task_wakeup(void) {[m
[32m+[m[32m    if (audio_event_group != NULL) {[m
[32m+[m[32m        xEventGroupSetBits(audio_event_group, AUDIO_DATA_READY_BIT);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mesp_err_t audio_direct_write(uint8_t *data) {[m
[32m+[m[32m    // Validate input[m
[32m+[m[32m    if (data == NULL) {[m
[32m+[m[32m        return ESP_ERR_INVALID_ARG;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Track active audio for power management[m
[32m+[m[32m    reduce_power_during_silence(true);[m
[32m+[m[41m    [m
[32m+[m[32m    esp_err_t err = ESP_OK;[m
[32m+[m[41m    [m
 #ifdef IS_USB[m
[31m-  uac_host_device_write(spkr_handle, data, PCM_CHUNK_SIZE, portMAX_DELAY);[m
[32m+[m[32m    if (spkr_handle != NULL) {[m
[32m+[m[32m        err = uac_host_device_write(spkr_handle, data, PCM_CHUNK_SIZE, portMAX_DELAY);[m
[32m+[m[32m        if (err != ESP_OK) {[m
[32m+[m[32m            ESP_LOGW(TAG, "Error writing to UAC device: %d", err);[m
[32m+[m[32m            return err;[m
[32m+[m[32m        }[m
[32m+[m[32m    } else {[m
[32m+[m[32m        return ESP_ERR_INVALID_STATE;[m
[32m+[m[32m    }[m
 #endif[m
[32m+[m
 #ifdef IS_SPDIF[m
[31m-			spdif_write(data, PCM_CHUNK_SIZE);[m
[32m+[m[32m    spdif_write(data, PCM_CHUNK_SIZE);[m
 #endif[m
[32m+[m
[32m+[m[32m    return ESP_OK;[m
 }[m
 [m
 void pcm_handler(void*) {[m
[31m-  while (true) {[m
[31m-	  if (playing) {[m
[31m-		uint8_t *data = pop_chunk();[m
[31m-		if (data) {[m
[32m+[m[32m    // Create event group for synchronization if not created already[m
[32m+[m[32m    audio_event_group = xEventGroupCreate();[m
[32m+[m[41m    [m
[32m+[m[32m    // Main audio processing loop[m
[32m+[m[32m    while (true) {[m
[32m+[m[32m        if (playing) {[m
[32m+[m[32m            uint8_t *data = pop_chunk();[m
[32m+[m[32m            if (data) {[m
[32m+[m[32m                // We have audio data[m
 #ifdef IS_USB[m
[31m-			uac_host_device_write(spkr_handle, data, PCM_CHUNK_SIZE, portMAX_DELAY);[m
[32m+[m[32m                if (spkr_handle != NULL) {[m
[32m+[m[32m                    esp_err_t err = uac_host_device_write(spkr_handle, data, PCM_CHUNK_SIZE, 100 / portTICK_PERIOD_MS);[m
[32m+[m[32m                    if (err != ESP_OK) {[m
[32m+[m[32m                        ESP_LOGW(TAG, "Error writing to UAC device: %d", err);[m
[32m+[m[32m                        // Continue despite error[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
 #endif[m
 #ifdef IS_SPDIF[m
[31m-			spdif_write(data, PCM_CHUNK_SIZE);[m
[32m+[m[32m                spdif_write(data, PCM_CHUNK_SIZE);[m
 #endif[m
[31m-			is_silent = false;[m
[31m-		}[m
[31m-		else if (!is_silent) {[m
[31m-			ESP_LOGI(TAG, "Silent");[m
[31m-			is_silent = true;[m
[31m-		}[m
[31m-		//else[m
[31m-//		    for (int i=0;i<1152/32;i++)[m
[31m-	//		    uac_host_device_write(spkr_handle, silence, 32, portMAX_DELAY);[m
[31m-		//	vTaskDelay(7);[m
[31m-	  }[m
[31m-    vTaskDelay(1);[m
[31m-  }[m
[32m+[m[32m                // Update activity status[m
[32m+[m[32m                if (is_silent) {[m
[32m+[m[32m                    ESP_LOGI(TAG, "Audio resumed after silence");[m
[32m+[m[32m                }[m
[32m+[m[32m                is_silent = false;[m
[32m+[m[32m                silent_period_count = 0;[m
[32m+[m[32m                reduce_power_during_silence(true);[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (!is_silent) {[m
[32m+[m[32m                // Just became silent[m
[32m+[m[32m                ESP_LOGI(TAG, "Silent");[m
[32m+[m[32m                is_silent = true;[m
[32m+[m[32m                silent_period_count = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // Continuing silence[m
[32m+[m[32m                silent_period_count++;[m
[32m+[m[41m                [m
[32m+[m[32m                // If we've been silent for a while, optimize power[m
[32m+[m[32m                if (silent_period_count >= SILENCE_POWER_REDUCTION_THRESHOLD) {[m
[32m+[m[32m                    // Enter power saving during extended silence[m
[32m+[m[32m                    reduce_power_during_silence(false);[m
[32m+[m[41m                    [m
[32m+[m[32m                    // Use event-based wait instead of polling during silence[m
[32m+[m[32m                    // This allows the CPU to idle or power down[m
[32m+[m[32m                    EventBits_t bits = xEventGroupWaitBits([m
[32m+[m[32m                        audio_event_group,[m
[32m+[m[32m                        AUDIO_DATA_READY_BIT | AUDIO_STOP_BIT,[m
[32m+[m[32m                        pdTRUE,   // Clear the bits after waiting[m
[32m+[m[32m                        pdFALSE,  // Wait for any bit, not all[m
[32m+[m[32m                        pdMS_TO_TICKS(AUDIO_CHECK_INTERVAL_MS));[m
[32m+[m[41m                    [m
[32m+[m[32m                    if (bits & AUDIO_STOP_BIT) {[m
[32m+[m[32m                        // Playback was stopped, reset state[m
[32m+[m[32m                        is_silent = false;[m
[32m+[m[32m                        silent_period_count = 0;[m
[32m+[m[32m                    }[m
[32m+[m[41m                    [m
[32m+[m[32m                    continue; // Skip the normal delay at the bottom[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // Not playing, wait for events instead of polling[m
[32m+[m[32m            xEventGroupWaitBits([m
[32m+[m[32m                audio_event_group,[m
[32m+[m[32m                AUDIO_DATA_READY_BIT,[m
[32m+[m[32m                pdTRUE,   // Clear the bits after waiting[m
[32m+[m[32m                pdFALSE,  // Wait for any bit[m
[32m+[m[32m                pdMS_TO_TICKS(AUDIO_CHECK_INTERVAL_MS));[m
[32m+[m[41m            [m
[32m+[m[32m            // Reset silence tracking when not playing[m
[32m+[m[32m            is_silent = false;[m
[32m+[m[32m            silent_period_count = 0;[m
[32m+[m[32m            continue; // Skip normal delay[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Small delay to prevent tight loop during active audio[m
[32m+[m[32m        vTaskDelay(1);[m
[32m+[m[32m    }[m
 }[m
 [m
 void setup_audio() {[m
 #ifdef IS_SPDIF[m
[31m-  spdif_init(48000);[m
[32m+[m[32m    spdif_init(48000);[m
 #endif[m
[31m-  xTaskCreatePinnedToCore(pcm_handler, "pcm_handler", 16384, NULL, 1, NULL, 1);[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m    xTaskCreatePinnedToCore(pcm_handler, "pcm_handler", 16384, NULL, 1, NULL, 1);[m
[32m+[m[41m    [m
[32m+[m[32m    // Initialize silence detection[m
[32m+[m[32m    is_silent = true;[m
[32m+[m[32m    silent_period_count = 0;[m
[32m+[m[32m}[m
[1mdiff --git a/main/audio.h b/main/audio.h[m
[1mindex 4477188..382735d 100644[m
[1m--- a/main/audio.h[m
[1m+++ b/main/audio.h[m
[36m@@ -1,15 +1,21 @@[m
 #pragma once[m
 #include "config.h"[m
[32m+[m[32m#include "esp_err.h"[m
 #ifdef IS_USB[m
 #include "usb/uac_host.h"[m
 #endif[m
[32m+[m
[32m+[m[32m// Function prototypes[m
 void process_audio_actions(bool is_startup);[m
 void register_button(int button,void (*action)(bool, int, void *));[m
 void setup_audio();[m
[32m+[m
[32m+[m[32m// Updated function signatures with error handling[m
 #ifdef IS_USB[m
[31m-void start_playback(uac_host_device_handle_t _spkr_handle);[m
[32m+[m[32mesp_err_t start_playback(uac_host_device_handle_t _spkr_handle);[m
 #endif[m
[31m-void stop_playback();[m
[32m+[m
[32m+[m[32mesp_err_t stop_playback();[m
 void audio_write(uint8_t* data);[m
[31m-void audio_direct_write(uint8_t *data);[m
[31m-void resume_playback();[m
\ No newline at end of file[m
[32m+[m[32mesp_err_t audio_direct_write(uint8_t *data);[m
[32m+[m[32mesp_err_t resume_playback();[m
[1mdiff --git a/main/buffer.c b/main/buffer.c[m
[1mindex e7a43ce..4cca85c 100644[m
[1m--- a/main/buffer.c[m
[1m+++ b/main/buffer.c[m
[36m@@ -2,87 +2,280 @@[m
 #include "global.h"[m
 #include "freertos/FreeRTOS.h"[m
 #include "freertos/task.h"[m
[32m+[m[32m#include "freertos/event_groups.h"[m
 #include <string.h>[m
 #include "esp_log.h"[m
 #include "esp_psram.h"[m
[32m+[m[32m#include "esp_timer.h"[m
 [m
[31m-// Flag if the stream is currently underrun and rebuffering[m
[31m-bool is_underrun                            = true;[m
[31m-// Number of received packets since last underflow[m
[31m-unsigned int received_packets               = 0;[m
[31m-// Number of packets in ring buffer[m
[31m-unsigned int packet_buffer_size             = 0;[m
[31m-// Position of ring buffer read head[m
[31m-unsigned int packet_buffer_pos              = 0;[m
[31m-// Number of bytes to buffer[m
[31m-unsigned int target_buffer_size             = INITIAL_BUFFER_SIZE;[m
[31m-// Buffer of packets to send[m
[31m-uint8_t *packet_buffer[MAX_BUFFER_SIZE] = { 0 };[m
[32m+[m[32m// Buffer state variables[m
[32m+[m[32mbool is_underrun = true;                           // Flag if the stream is currently underrun and rebuffering[m
[32m+[m[32munsigned int received_packets = 0;                 // Number of received packets since last underflow[m
[32m+[m[32munsigned int packet_buffer_size = 0;               // Number of packets in ring buffer[m
[32m+[m[32munsigned int packet_buffer_pos = 0;                // Position of ring buffer read head[m
[32m+[m[32munsigned int target_buffer_size = INITIAL_BUFFER_SIZE; // Number of bytes to buffer[m
[32m+[m[32muint8_t *packet_buffer[MAX_BUFFER_SIZE] = { 0 };   // Buffer of packets to send[m
 portMUX_TYPE buffer_mutex = portMUX_INITIALIZER_UNLOCKED;[m
 [m
[32m+[m[32m// Event group for buffer signaling[m
[32m+[m[32mEventGroupHandle_t buffer_event_group = NULL;[m
[32m+[m[32m#define BUFFER_DATA_READY_BIT (1 << 0)[m
[32m+[m[32m#define BUFFER_EMPTY_BIT (1 << 1)[m
[32m+[m
[32m+[m[32m// Power optimization[m
[32m+[m[32m#define BUFFER_MONITORING_INTERVAL_MS 50 // How often to check buffer status when idle[m
[32m+[m[32mstatic uint32_t last_buffer_activity = 0; // Timestamp of last buffer activity[m
[32m+[m[32mstatic bool low_power_buffer_mode = false; // Whether we're in power-saving buffer mode[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Signal that data is ready in the buffer[m
[32m+[m[32m * This wakes up any tasks waiting for buffer data[m
[32m+[m[32m */[m
[32m+[m[32mstatic void signal_buffer_ready(void) {[m
[32m+[m[32m    if (buffer_event_group != NULL) {[m
[32m+[m[32m        xEventGroupSetBits(buffer_event_group, BUFFER_DATA_READY_BIT);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Update activity tracking[m
[32m+[m[32m    last_buffer_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[41m    [m
[32m+[m[32m    // If we were in low power mode, exit it[m
[32m+[m[32m    if (low_power_buffer_mode) {[m
[32m+[m[32m        low_power_buffer_mode = false;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Update global activity time for main task power management[m
[32m+[m[32m    extern uint32_t g_last_audio_activity;[m
[32m+[m[32m    g_last_audio_activity = last_buffer_activity;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Signal that the buffer is empty[m
[32m+[m[32m */[m
[32m+[m[32mstatic void signal_buffer_empty(void) {[m
[32m+[m[32m    if (buffer_event_group != NULL) {[m
[32m+[m[32m        xEventGroupSetBits(buffer_event_group, BUFFER_EMPTY_BIT);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Set underrun state and adjust buffer size[m
[32m+[m[32m * Uses adaptive buffer sizing to prevent future underruns[m
[32m+[m[32m */[m
 void set_underrun() {[m
[31m-  if (!is_underrun) {[m
[31m-    received_packets = 0;[m
[31m-    target_buffer_size += BUFFER_GROW_STEP_SIZE;[m
[31m-    if (target_buffer_size >= MAX_GROW_SIZE)[m
[31m-      target_buffer_size = MAX_GROW_SIZE;[m
[31m-    ESP_LOGI(TAG, "Buffer Underflow, New Size: %i", target_buffer_size);[m
[31m-  }[m
[31m-  is_underrun = true;[m
[32m+[m[32m    if (!is_underrun) {[m
[32m+[m[32m        received_packets = 0;[m
[32m+[m[41m        [m
[32m+[m[32m        // Adaptively grow buffer size to prevent future underruns[m
[32m+[m[32m        // but only if buffer growth is enabled (BUFFER_GROW_STEP_SIZE > 0)[m
[32m+[m[32m        if (BUFFER_GROW_STEP_SIZE > 0) {[m
[32m+[m[32m            target_buffer_size += BUFFER_GROW_STEP_SIZE;[m
[32m+[m[32m            if (target_buffer_size >= MAX_GROW_SIZE)[m
[32m+[m[32m                target_buffer_size = MAX_GROW_SIZE;[m
[32m+[m[32m            ESP_LOGI(TAG, "Buffer Underflow, New Size: %i", target_buffer_size);[m
[32m+[m[32m        } else {[m
[32m+[m[32m            ESP_LOGI(TAG, "Buffer Underflow");[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Signal buffer empty to any waiting tasks[m
[32m+[m[32m        signal_buffer_empty();[m
[32m+[m[32m    }[m
[32m+[m[32m    is_underrun = true;[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Push a chunk of audio data to the buffer[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @param chunk Pointer to audio data[m
[32m+[m[32m * @return true if successful, false if buffer is full[m
[32m+[m[32m */[m
 bool push_chunk(uint8_t *chunk) {[m
[31m-  int write_position = (packet_buffer_pos + packet_buffer_size) % MAX_BUFFER_SIZE;[m
[31m-//  ESP_LOGI(TAG, "memcpy(%p, %p, %i)", packet_buffer[write_position], chunk, PCM_CHUNK_SIZE); [m
[31m-  taskENTER_CRITICAL(&buffer_mutex);[m
[31m-  if (packet_buffer_size == MAX_BUFFER_SIZE) {[m
[31m-    packet_buffer_size = target_buffer_size;[m
[31m-    taskEXIT_CRITICAL(&buffer_mutex);[m
[31m-    ESP_LOGI(TAG, "Buffer Overflow");[m
[31m-    return false;[m
[31m-  }[m
[32m+[m[32m    int write_position = (packet_buffer_pos + packet_buffer_size) % MAX_BUFFER_SIZE;[m
[32m+[m[41m    [m
[32m+[m[32m    taskENTER_CRITICAL(&buffer_mutex);[m
[32m+[m[41m    [m
[32m+[m[32m    // Handle buffer overflow[m
[32m+[m[32m    if (packet_buffer_size == MAX_BUFFER_SIZE) {[m
[32m+[m[32m        // Reset to target size when overflowed[m
[32m+[m[32m        packet_buffer_size = target_buffer_size;[m
[32m+[m[32m        taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[32m        ESP_LOGI(TAG, "Buffer Overflow");[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
 [m
[31m-  write_position = (packet_buffer_pos + packet_buffer_size) % MAX_BUFFER_SIZE;[m
[31m-  memcpy(packet_buffer[write_position], chunk, PCM_CHUNK_SIZE);[m
[31m-  packet_buffer_size++;[m
[31m-  received_packets++;[m
[31m-  if (received_packets >= target_buffer_size)[m
[31m-    is_underrun = false;[m
[31m-  taskEXIT_CRITICAL(&buffer_mutex);[m
[31m-  return true;[m
[32m+[m[32m    // Add chunk to buffer[m
[32m+[m[32m    write_position = (packet_buffer_pos + packet_buffer_size) % MAX_BUFFER_SIZE;[m
[32m+[m[32m    memcpy(packet_buffer[write_position], chunk, PCM_CHUNK_SIZE);[m
[32m+[m[32m    packet_buffer_size++;[m
[32m+[m[32m    received_packets++;[m
[32m+[m[41m    [m
[32m+[m[32m    // Check if we've received enough data to exit underrun state[m
[32m+[m[32m    bool was_underrun = is_underrun;[m
[32m+[m[32m    if (received_packets >= target_buffer_size)[m
[32m+[m[32m        is_underrun = false;[m
[32m+[m[41m    [m
[32m+[m[32m    taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[41m    [m
[32m+[m[32m    // If we've just filled the buffer enough to play, signal that data is ready[m
[32m+[m[32m    if (was_underrun && !is_underrun) {[m
[32m+[m[32m        ESP_LOGI(TAG, "Buffer ready for playback (%d packets)", received_packets);[m
[32m+[m[32m        signal_buffer_ready();[m
[32m+[m[32m    } else if (packet_buffer_size == 1 && was_underrun) {[m
[32m+[m[32m        // First packet after empty buffer, signal data ready[m
[32m+[m[32m        signal_buffer_ready();[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    return true;[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Pop a chunk of audio data from the buffer[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @return Pointer to audio data or NULL if buffer is empty or underrun[m
[32m+[m[32m */[m
 uint8_t *pop_chunk() {[m
[31m-  taskENTER_CRITICAL(&buffer_mutex);[m
[31m-  if (packet_buffer_size == 0) {[m
[32m+[m[32m    uint8_t *return_chunk = NULL;[m
[32m+[m[32m    bool empty = false;[m
[32m+[m[41m    [m
[32m+[m[32m    taskENTER_CRITICAL(&buffer_mutex);[m
[32m+[m[41m    [m
[32m+[m[32m    // Check if buffer is empty[m
[32m+[m[32m    if (packet_buffer_size == 0) {[m
[32m+[m[32m        empty = true;[m
[32m+[m[32m        taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[32m        set_underrun();[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Check if we're in underrun state[m
[32m+[m[32m    if (is_underrun) {[m
[32m+[m[32m        taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Get chunk from buffer[m
[32m+[m[32m    return_chunk = packet_buffer[packet_buffer_pos];[m
[32m+[m[32m    packet_buffer_size--;[m
[32m+[m[32m    packet_buffer_pos = (packet_buffer_pos + 1) % MAX_BUFFER_SIZE;[m
[32m+[m[41m    [m
[32m+[m[32m    // Check if this was the last chunk[m
[32m+[m[32m    if (packet_buffer_size == 0) {[m
[32m+[m[32m        empty = true;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
     taskEXIT_CRITICAL(&buffer_mutex);[m
[31m-    set_underrun();[m
[31m-    return NULL;[m
[31m-  }[m
[31m-  if (is_underrun) {[m
[31m-    taskEXIT_CRITICAL(&buffer_mutex);[m
[31m-    return NULL;[m
[31m-  }[m
[31m-  uint8_t *return_chunk = packet_buffer[packet_buffer_pos];[m
[31m-  packet_buffer_size--;[m
[31m-  packet_buffer_pos = (packet_buffer_pos + 1) % MAX_BUFFER_SIZE;[m
[31m-  taskEXIT_CRITICAL(&buffer_mutex);[m
[31m-  return return_chunk;[m
[32m+[m[41m    [m
[32m+[m[32m    // Signal if buffer just became empty[m
[32m+[m[32m    if (empty) {[m
[32m+[m[32m        signal_buffer_empty();[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Update activity timestamp[m
[32m+[m[32m    if (return_chunk != NULL) {[m
[32m+[m[32m        last_buffer_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    return return_chunk;[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Empty the buffer and reset state[m
[32m+[m[32m */[m
 void empty_buffer() {[m
[31m-	taskENTER_CRITICAL(&buffer_mutex);[m
[31m-	packet_buffer_size = 0;[m
[31m-	received_packets = 0;[m
[31m-	taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[32m    taskENTER_CRITICAL(&buffer_mutex);[m
[32m+[m[32m    packet_buffer_size = 0;[m
[32m+[m[32m    received_packets = 0;[m
[32m+[m[32m    taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[41m    [m
[32m+[m[32m    // Signal buffer empty to any waiting tasks[m
[32m+[m[32m    signal_buffer_empty();[m
[32m+[m[41m    [m
[32m+[m[32m    // Set low power mode since buffer is empty[m
[32m+[m[32m    low_power_buffer_mode = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Check if buffer is empty[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @return true if buffer is empty, false otherwise[m
[32m+[m[32m */[m
[32m+[m[32mbool is_buffer_empty(void) {[m
[32m+[m[32m    bool empty = false;[m
[32m+[m[41m    [m
[32m+[m[32m    taskENTER_CRITICAL(&buffer_mutex);[m
[32m+[m[32m    empty = (packet_buffer_size == 0);[m
[32m+[m[32m    taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[41m    [m
[32m+[m[32m    return empty;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Get current buffer fullness as percentage[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @return Percentage of buffer fullness (0-100)[m
[32m+[m[32m */[m
[32m+[m[32muint8_t get_buffer_fullness(void) {[m
[32m+[m[32m    uint8_t fullness = 0;[m
[32m+[m[41m    [m
[32m+[m[32m    taskENTER_CRITICAL(&buffer_mutex);[m
[32m+[m[32m    if (MAX_BUFFER_SIZE > 0) {[m
[32m+[m[32m        fullness = (packet_buffer_size * 100) / MAX_BUFFER_SIZE;[m
[32m+[m[32m    }[m
[32m+[m[32m    taskEXIT_CRITICAL(&buffer_mutex);[m
[32m+[m[41m    [m
[32m+[m[32m    return fullness;[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Wait for buffer data with timeout[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @param timeout_ms Timeout in milliseconds[m
[32m+[m[32m * @return true if data is available, false on timeout[m
[32m+[m[32m */[m
[32m+[m[32mbool wait_for_buffer_data(uint32_t timeout_ms) {[m
[32m+[m[32m    if (buffer_event_group == NULL) {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Wait for buffer data event[m
[32m+[m[32m    EventBits_t bits = xEventGroupWaitBits([m
[32m+[m[32m        buffer_event_group,[m
[32m+[m[32m        BUFFER_DATA_READY_BIT,[m
[32m+[m[32m        pdTRUE,   // Clear the bits after waiting[m
[32m+[m[32m        pdFALSE,  // Wait for any bit[m
[32m+[m[32m        pdMS_TO_TICKS(timeout_ms));[m
[32m+[m[41m    [m
[32m+[m[32m    return (bits & BUFFER_DATA_READY_BIT) != 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Setup the buffer system[m
[32m+[m[32m */[m
 void setup_buffer() {[m
[31m-  ESP_LOGI(TAG, "Allocating buffer");[m
[31m-  uint8_t *buffer = 0;[m
[31m-  buffer = (uint8_t *)malloc(PCM_CHUNK_SIZE * MAX_BUFFER_SIZE);[m
[31m-  memset(buffer, 0, PCM_CHUNK_SIZE * MAX_BUFFER_SIZE);[m
[31m-  for (int i = 0; i < MAX_BUFFER_SIZE; i++)[m
[31m-    packet_buffer[i] = (uint8_t *)buffer + i * PCM_CHUNK_SIZE;[m
[31m-  ESP_LOGI(TAG, "Buffer allocated");[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m    ESP_LOGI(TAG, "Allocating buffer");[m
[32m+[m[41m    [m
[32m+[m[32m    // Create a single contiguous block of memory for all buffer chunks[m
[32m+[m[32m    uint8_t *buffer = (uint8_t *)malloc(PCM_CHUNK_SIZE * MAX_BUFFER_SIZE);[m
[32m+[m[32m    if (buffer == NULL) {[m
[32m+[m[32m        ESP_LOGE(TAG, "Failed to allocate buffer memory!");[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Clear buffer memory[m
[32m+[m[32m    memset(buffer, 0, PCM_CHUNK_SIZE * MAX_BUFFER_SIZE);[m
[32m+[m[41m    [m
[32m+[m[32m    // Setup buffer pointers[m
[32m+[m[32m    for (int i = 0; i < MAX_BUFFER_SIZE; i++) {[m
[32m+[m[32m        packet_buffer[i] = buffer + (i * PCM_CHUNK_SIZE);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Create event group for buffer events[m
[32m+[m[32m    buffer_event_group = xEventGroupCreate();[m
[32m+[m[41m    [m
[32m+[m[32m    // Initialize activity tracking[m
[32m+[m[32m    last_buffer_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[32m    low_power_buffer_mode = true;[m
[32m+[m[41m    [m
[32m+[m[32m    ESP_LOGI(TAG, "Buffer allocated: %d bytes for %d chunks",[m[41m [m
[32m+[m[32m             PCM_CHUNK_SIZE * MAX_BUFFER_SIZE, MAX_BUFFER_SIZE);[m
[32m+[m[32m}[m
[1mdiff --git a/main/buffer.h b/main/buffer.h[m
[1mindex 21746ce..bb15ae1 100644[m
[1m--- a/main/buffer.h[m
[1m+++ b/main/buffer.h[m
[36m@@ -1,13 +1,20 @@[m
 #pragma once[m
 [m
[32m+[m[32m// External variables for buffer state[m
 extern bool is_underrun;[m
 extern uint64_t received_packets;[m
 extern uint64_t packet_buffer_size;[m
 extern uint64_t packet_buffer_pos;[m
 extern uint64_t target_buffer_size;[m
 [m
[31m-void setup_buffer();[m
[32m+[m[32m// Buffer management functions[m
[32m+[m[32mvoid set_underrun(void);[m
 bool push_chunk(uint8_t *chunk);[m
[31m-uint8_t *pop_chunk();[m
[31m-void setup_buffer();[m
[31m-void empty_buffer();[m
\ No newline at end of file[m
[32m+[m[32muint8_t *pop_chunk(void);[m
[32m+[m[32mvoid empty_buffer(void);[m
[32m+[m[32mvoid setup_buffer(void);[m
[32m+[m
[32m+[m[32m// New power-optimized buffer functions[m
[32m+[m[32mbool is_buffer_empty(void);[m
[32m+[m[32muint8_t get_buffer_fullness(void);[m
[32m+[m[32mbool wait_for_buffer_data(uint32_t timeout_ms);[m
[1mdiff --git a/main/config.h b/main/config.h[m
[1mindex ff0073c..6e8193b 100644[m
[1m--- a/main/config.h[m
[1m+++ b/main/config.h[m
[36m@@ -7,7 +7,7 @@[m
 // Number of chunks to add each underflow, configurable[m
 #define BUFFER_GROW_STEP_SIZE 0[m
 // Max number of chunks to be buffered before packets are dropped, configurable[m
[31m-#define  MAX_BUFFER_SIZE 16[m
[32m+[m[32m#define MAX_BUFFER_SIZE 16[m
 // Max number of chunks to be targeted for buffer[m
 #define MAX_GROW_SIZE 4[m
 [m
[36m@@ -18,7 +18,18 @@[m
 //Volume 0.0f-1.0f[m
 #define VOLUME 1.0f[m
 [m
[32m+[m[32m// Power management settings[m
[32m+[m[32m#define WIFI_POWER_SAVE_ENABLED 1         // Enable WiFi power saving[m
[32m+[m[32m#define WIFI_LISTEN_INTERVAL 3            // Listen interval for beacons (higher = more power saving)[m
[32m+[m[32m#define WIFI_RSSI_THRESHOLD (-70)         // RSSI threshold for roaming (lower = less roaming)[m
[32m+[m[32m#define CPU_FREQ_DURING_AUDIO 240         // Maximum CPU frequency during audio playback (MHz)[m
[32m+[m[32m#define CPU_FREQ_DURING_IDLE 80           // Reduced CPU frequency during idle (MHz)[m
[32m+[m[32m#define DEEP_SLEEP_CHECK_INTERVAL_MS 5000 // How often to wake and check for USB when in deep sleep[m
[32m+[m
[32m+[m[32m// Audio input format (hard-coded, don't change)[m
[32m+[m[32m#define PCM_CHUNK_SIZE (1152 * 2 * 2)     // 1152 stereo samples, 16-bit[m
[32m+[m
 //#define IS_SPDIF[m
 #define IS_USB[m
 [m
[31m-#define TAG "scream_receiver"[m
\ No newline at end of file[m
[32m+[m[32m#define TAG "scream_receiver"[m
[1mdiff --git a/main/global.h b/main/global.h[m
[1mindex 1b23abf..17dd2e6 100644[m
[1m--- a/main/global.h[m
[1m+++ b/main/global.h[m
[36m@@ -2,5 +2,4 @@[m
 #include "stdint.h"[m
 #include "config.h"[m
 #include "stdbool.h"[m
[31m-// PCM Bytes per chunk, non-configurable (Part of Scream)[m
[31m-#define PCM_CHUNK_SIZE 1152[m
[32m+[m[32m// PCM chunk size is now defined in config.h - we'll use that definition[m
[1mdiff --git a/main/network.c b/main/network.c[m
[1mindex 5611281..4d6f1a1 100644[m
[1m--- a/main/network.c[m
[1m+++ b/main/network.c[m
[36m@@ -10,9 +10,13 @@[m
 #include "esp_event.h"[m
 #include "esp_log.h"[m
 #include "nvs_flash.h"[m
[32m+[m[32m#include "esp_pm.h"[m
 [m
 #include "lwip/err.h"[m
 #include "lwip/sys.h"[m
[32m+[m[32m#include "lwip/sockets.h"[m
[32m+[m[32m#include "lwip/netdb.h"[m
[32m+[m[32m#include "lwip/dns.h"[m
 [m
 #include <string.h>[m
 #include <unistd.h>[m
[36m@@ -24,114 +28,236 @@[m
 #include "secrets.h"[m
 #include "audio.h"[m
 [m
[31m-const uint16_t HEADER_SIZE = 0;                         // Scream Header byte size, non-configurable (Part of Scream)[m
[32m+[m[32mconst uint16_t HEADER_SIZE = 5;                         // Scream Header byte size, non-configurable (Part of Scream)[m
 const uint16_t PACKET_SIZE = PCM_CHUNK_SIZE + HEADER_SIZE;[m
[31m-bool use_tcp = true;[m
[32m+[m[32mbool use_tcp = false;[m
 bool connected = false;[m
 [m
[32m+[m[32m// Power optimization settings[m
[32m+[m[32m#define SOCKET_RECV_TIMEOUT_MS 100   // Use timeout instead of blocking[m
[32m+[m[32m#define NETWORK_TASK_STACK_SIZE 8192[m
[32m+[m[32m#define MAX_IDLE_TIME_MS 5000        // Max time with no data before reducing power[m
[32m+[m
 char server[16] = {0};[m
[32m+[m[32mEventGroupHandle_t network_event_group = NULL;[m
[32m+[m
[32m+[m[32m// Event bits for network events[m
[32m+[m[32m#define NETWORK_DATA_RECEIVED_BIT (1 << 0)[m
[32m+[m[32m#define NETWORK_DISCONNECTED_BIT  (1 << 1)[m
 [m
[32m+[m[32m// Track last activity for power management[m
[32m+[m[32mstatic uint32_t last_data_received_time = 0;[m
[32m+[m[32mstatic bool power_save_enabled = false;[m
[32m+[m
[32m+[m[32m// Forward declarations[m
 void udp_handler(void *);[m
[31m-void tcp_handler(void *);  [m
[32m+[m[32mvoid tcp_handler(void *);[m
[32m+[m[32mvoid update_power_management(bool has_activity);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Check for network activity and adjust power settings accordingly[m
[32m+[m[32m */[m
[32m+[m[32mvoid update_power_management(bool has_activity) {[m
[32m+[m[32m    uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[41m    [m
[32m+[m[32m    if (has_activity) {[m
[32m+[m[32m        // Activity detected, update timestamp[m
[32m+[m[32m        last_data_received_time = current_time;[m
[32m+[m[41m        [m
[32m+[m[32m        // If we were in power save mode, exit it[m
[32m+[m[32m        if (power_save_enabled) {[m
[32m+[m[32m            ESP_LOGD(TAG, "Network activity detected, disabling power save");[m
[32m+[m[32m            esp_wifi_set_ps(WIFI_PS_MIN_MODEM); // Less aggressive power save[m
[32m+[m[32m            power_save_enabled = false;[m
[32m+[m[41m            [m
[32m+[m[32m            // Record activity for main task to know we're active[m
[32m+[m[32m            extern uint32_t g_last_audio_activity;[m
[32m+[m[32m            g_last_audio_activity = current_time;[m
[32m+[m[32m        }[m
[32m+[m[32m    } else {[m
[32m+[m[32m        // Check if it's been too long since last activity[m
[32m+[m[32m        if (!power_save_enabled &&[m[41m [m
[32m+[m[32m            current_time - last_data_received_time > MAX_IDLE_TIME_MS) {[m
[32m+[m[32m            // No activity for a while, enable power save[m
[32m+[m[32m            ESP_LOGD(TAG, "Network idle for %u ms, enabling max power save",[m
[32m+[m[32m                   (unsigned)(current_time - last_data_received_time));[m
[32m+[m[32m            esp_wifi_set_ps(WIFI_PS_MAX_MODEM); // Max power save[m
[32m+[m[32m            power_save_enabled = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
 [m
 void tcp_handler(void *) {[m
[31m-  int connect_failure = 0;[m
[31m-  struct sockaddr_in dest_addr;[m
[31m-  inet_pton(AF_INET, server, &dest_addr.sin_addr);[m
[31m-  dest_addr.sin_family = AF_INET;[m
[31m-  dest_addr.sin_port = htons(PORT);[m
[31m-  int sock =  socket(AF_INET, SOCK_STREAM, IPPROTO_IP);[m
[31m-  const int ip_precedence_vi = 6;[m
[31m-  const int ip_precedence_offset = 5;[m
[31m-  int priority = (ip_precedence_vi << ip_precedence_offset);[m
[31m-  setsockopt(sock, IPPROTO_IP, IP_TOS, &priority, sizeof(priority));[m
[31m-  int val = 1;[m
[31m-  setsockopt(sock, 6/*SOL_TCP*/, TCP_NODELAY, &val, sizeof(val));[m
[31m-  empty_buffer();[m
[31m-  ESP_LOGI(TAG, "Connecting to ScreamRouter");[m
[31m-  while (!connected) {[m
[31m-    ESP_LOGI(TAG, "Failed to connect");[m
[31m-	int err = connect(sock, (struct sockaddr *)&dest_addr, sizeof(dest_addr));[m
[31m-	if (err != 0) {[m
[31m-		ESP_LOGE(TAG, "Socket unable to connect: errno %d", errno);[m
[31m-	} else {[m
[31m-		connected = true;[m
[31m-		break;[m
[31m-	}[m
[31m-    vTaskDelay(250);[m
[31m-    if (connect_failure++ >= 50)[m
[31m-      ESP_LOGI(TAG, "wifi isn't connecting");[m
[31m-  }[m
[31m-  ESP_LOGI(TAG, "Connected to ScreamRouter");[m
[31m-  uint8_t data[PACKET_SIZE * 2];[m
[31m-  uint16_t datahead = 0;[m
[31m-  resume_playback();[m
[31m-  while (connected) {[m
[31m-	int result = recv(sock, data + datahead, PACKET_SIZE, 0);[m
[31m-	if (!result)[m
[31m-		connected = false;[m
[31m-	datahead += result;[m
[31m-	if (datahead >= PACKET_SIZE) {[m
[31m-		//push_chunk(data + HEADER_SIZE);[m
[31m-		audio_direct_write(data + HEADER_SIZE);[m
[31m-		memcpy(data, data + PACKET_SIZE, PACKET_SIZE);[m
[31m-		datahead -= PACKET_SIZE;[m
[31m-	}[m
[31m-    vTaskDelay(1);[m
[31m-  }[m
[31m-  close(sock);[m
[31m-  stop_playback();[m
[31m-  xTaskCreatePinnedToCore(udp_handler, "udp_handler", 8192, NULL, 1, NULL, 1);[m
[31m-  vTaskDelete(NULL);[m
[32m+[m[32m    int connect_failure = 0;[m
[32m+[m[32m    struct sockaddr_in dest_addr;[m
[32m+[m[32m    inet_pton(AF_INET, server, &dest_addr.sin_addr);[m
[32m+[m[32m    dest_addr.sin_family = AF_INET;[m
[32m+[m[32m    dest_addr.sin_port = htons(PORT);[m
[32m+[m[32m    int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);[m
[32m+[m[41m    [m
[32m+[m[32m    // Configure socket for power efficiency[m
[32m+[m[32m    const int ip_precedence_vi = 6;[m
[32m+[m[32m    const int ip_precedence_offset = 5;[m
[32m+[m[32m    int priority = (ip_precedence_vi << ip_precedence_offset);[m
[32m+[m[32m    setsockopt(sock, IPPROTO_IP, IP_TOS, &priority, sizeof(priority));[m
[32m+[m[41m    [m
[32m+[m[32m    // Set TCP_NODELAY to reduce latency[m
[32m+[m[32m    int val = 1;[m
[32m+[m[32m    setsockopt(sock, 6/*SOL_TCP*/, TCP_NODELAY, &val, sizeof(val));[m
[32m+[m[41m    [m
[32m+[m[32m    // Set receive timeout to avoid blocking forever[m
[32m+[m[32m    struct timeval timeout;[m
[32m+[m[32m    timeout.tv_sec = 0;[m
[32m+[m[32m    timeout.tv_usec = SOCKET_RECV_TIMEOUT_MS * 1000;[m
[32m+[m[32m    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));[m
[32m+[m[41m    [m
[32m+[m[32m    empty_buffer();[m
[32m+[m[32m    ESP_LOGI(TAG, "Connecting to ScreamRouter");[m
[32m+[m[41m    [m
[32m+[m[32m    while (!connected) {[m
[32m+[m[32m        int err = connect(sock, (struct sockaddr *)&dest_addr, sizeof(dest_addr));[m
[32m+[m[32m        if (err != 0) {[m
[32m+[m[32m            ESP_LOGE(TAG, "Socket unable to connect: errno %d", errno);[m
[32m+[m[32m        } else {[m
[32m+[m[32m            connected = true;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        vTaskDelay(pdMS_TO_TICKS(250));[m
[32m+[m[32m        if (connect_failure++ >= 50) {[m
[32m+[m[32m            ESP_LOGI(TAG, "WiFi isn't connecting");[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    ESP_LOGI(TAG, "Connected to ScreamRouter");[m
[32m+[m[32m    uint8_t data[PACKET_SIZE * 2];[m
[32m+[m[32m    uint16_t datahead = 0;[m
[32m+[m[32m    resume_playback();[m
[32m+[m[41m    [m
[32m+[m[32m    // Initialize activity tracking[m
[32m+[m[32m    last_data_received_time = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[41m    [m
[32m+[m[32m    while (connected) {[m
[32m+[m[32m        // Receive data with timeout[m
[32m+[m[32m        int result = recv(sock, data + datahead, PACKET_SIZE, 0);[m
[32m+[m[41m        [m
[32m+[m[32m        if (result > 0) {[m
[32m+[m[32m            // Data received, update activity status[m
[32m+[m[32m            update_power_management(true);[m
[32m+[m[41m            [m
[32m+[m[32m            datahead += result;[m
[32m+[m[32m            if (datahead >= PACKET_SIZE) {[m
[32m+[m[32m                //push_chunk(data + HEADER_SIZE);[m
[32m+[m[32m                audio_direct_write(data + HEADER_SIZE);[m
[32m+[m[32m                memcpy(data, data + PACKET_SIZE, PACKET_SIZE);[m
[32m+[m[32m                datahead -= PACKET_SIZE;[m
[32m+[m[32m            }[m
[32m+[m[32m        } else if (result == 0) {[m
[32m+[m[32m            // Connection closed[m
[32m+[m[32m            connected = false;[m
[32m+[m[32m        } else {[m
[32m+[m[32m            // Check if this is a timeout or an actual error[m
[32m+[m[32m            if (errno == EAGAIN || errno == EWOULDBLOCK) {[m
[32m+[m[32m                // Timeout - check if we need to adjust power management[m
[32m+[m[32m                update_power_management(false);[m
[32m+[m[32m            } else {[m
[32m+[m[32m                // Real error[m
[32m+[m[32m                ESP_LOGE(TAG, "Socket error: %d", errno);[m
[32m+[m[32m                connected = false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Use a very small delay instead of continuous polling[m
[32m+[m[32m        vTaskDelay(1);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    close(sock);[m
[32m+[m[32m    stop_playback();[m
[32m+[m[32m    xTaskCreatePinnedToCore(udp_handler, "udp_handler", NETWORK_TASK_STACK_SIZE, NULL, 1, NULL, 1);[m
[32m+[m[32m    vTaskDelete(NULL);[m
 }[m
 [m
 void udp_handler(void *) {[m
[31m-	uint8_t data[PACKET_SIZE * 2];[m
[31m-	uint16_t datahead = 0;[m
[31m-	empty_buffer();[m
[32m+[m[32m    uint8_t data[PACKET_SIZE * 2];[m
[32m+[m[32m    uint16_t datahead = 0;[m
[32m+[m[32m    empty_buffer();[m
[32m+[m[41m    [m
     while (1) {[m
[31m-		struct sockaddr_in dest_addr_ip4;[m
[31m-		dest_addr_ip4.sin_addr.s_addr = htonl(INADDR_ANY);[m
[31m-		dest_addr_ip4.sin_family = AF_INET;[m
[31m-		dest_addr_ip4.sin_port = htons(PORT);[m
[32m+[m[32m        struct sockaddr_in dest_addr_ip4;[m
[32m+[m[32m        dest_addr_ip4.sin_addr.s_addr = htonl(INADDR_ANY);[m
[32m+[m[32m        dest_addr_ip4.sin_family = AF_INET;[m
[32m+[m[32m        dest_addr_ip4.sin_port = htons(PORT);[m
 [m
         int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);[m
[31m-	    const int ip_precedence_vi = 6;[m
[31m-		const int ip_precedence_offset = 5;[m
[31m-		int priority = (ip_precedence_vi << ip_precedence_offset);[m
[31m-	    setsockopt(sock, IPPROTO_IP, IP_TOS, &priority, sizeof(priority));[m
[32m+[m[32m        const int ip_precedence_vi = 6;[m
[32m+[m[32m        const int ip_precedence_offset = 5;[m
[32m+[m[32m        int priority = (ip_precedence_vi << ip_precedence_offset);[m
[32m+[m[32m        setsockopt(sock, IPPROTO_IP, IP_TOS, &priority, sizeof(priority));[m
[32m+[m[41m        [m
[32m+[m[32m        // Set receive timeout to avoid blocking forever[m
[32m+[m[32m        struct timeval timeout;[m
[32m+[m[32m        timeout.tv_sec = 0;[m
[32m+[m[32m        timeout.tv_usec = SOCKET_RECV_TIMEOUT_MS * 1000;[m
[32m+[m[32m        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));[m
[32m+[m[41m        [m
         if (sock < 0) {[m
             ESP_LOGE(TAG, "Unable to create socket: errno %d", errno);[m
             break;[m
         }[m
[32m+[m[41m        [m
         ESP_LOGI(TAG, "Socket created");[m
 [m
         int err = bind(sock, (struct sockaddr *)&dest_addr_ip4, sizeof(dest_addr_ip4));[m
         if (err < 0) {[m
             ESP_LOGE(TAG, "Socket unable to bind: errno %d", errno);[m
         }[m
[32m+[m[41m        [m
         ESP_LOGI(TAG, "Socket bound, port %d", PORT);[m
[31m-		resume_playback();[m
[32m+[m[32m        resume_playback();[m
[32m+[m[41m        [m
[32m+[m[32m        // Initialize activity tracking[m
[32m+[m[32m        last_data_received_time = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[41m        [m
         while (1) {[m
             int result = recv(sock, data + datahead, PACKET_SIZE, 0);[m
[31m-			if (result && use_tcp) {[m
[31m-				struct sockaddr_in addr;[m
[31m-				socklen_t addrlen = sizeof(struct sockaddr_in);[m
[31m-				recvfrom(sock, data + datahead, PACKET_SIZE, 0, (struct sockaddr *)&addr, &addrlen);[m
[31m-				strcpy(server, inet_ntoa(addr.sin_addr));[m
[31m-				xTaskCreatePinnedToCore(tcp_handler, "tcp_handler", 8192, NULL, 1, NULL, 1);[m
[31m-				close(sock);[m
[31m-				stop_playback();[m
[31m-				vTaskDelete(NULL);[m
[31m-				return;[m
[31m-			}[m
[31m-		 	datahead += result;[m
[31m-			if (datahead >= PACKET_SIZE) {[m
[31m-				//push_chunk(data + HEADER_SIZE);[m
[31m-				audio_direct_write(data + HEADER_SIZE);[m
[31m-				memcpy(data,data + PACKET_SIZE, PACKET_SIZE);[m
[31m-				datahead -= PACKET_SIZE;[m
[31m-			}[m
[32m+[m[41m            [m
[32m+[m[32m            if (result > 0) {[m
[32m+[m[32m                // Data received, update activity status[m
[32m+[m[32m                update_power_management(true);[m
[32m+[m[41m                [m
[32m+[m[32m                if (use_tcp) {[m
[32m+[m[32m                    struct sockaddr_in addr;[m
[32m+[m[32m                    socklen_t addrlen = sizeof(struct sockaddr_in);[m
[32m+[m[32m                    recvfrom(sock, data + datahead, PACKET_SIZE, 0, (struct sockaddr *)&addr, &addrlen);[m
[32m+[m[32m                    strcpy(server, inet_ntoa(addr.sin_addr));[m
[32m+[m[32m                    xTaskCreatePinnedToCore(tcp_handler, "tcp_handler", NETWORK_TASK_STACK_SIZE, NULL, 1, NULL, 1);[m
[32m+[m[32m                    close(sock);[m
[32m+[m[32m                    stop_playback();[m
[32m+[m[32m                    vTaskDelete(NULL);[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[41m                [m
[32m+[m[32m                datahead += result;[m
[32m+[m[32m                if (datahead >= PACKET_SIZE) {[m
[32m+[m[32m                    //push_chunk(data + HEADER_SIZE);[m
[32m+[m[32m                    audio_direct_write(data + HEADER_SIZE);[m
[32m+[m[32m                    memcpy(data, data + PACKET_SIZE, PACKET_SIZE);[m
[32m+[m[32m                    datahead -= PACKET_SIZE;[m
[32m+[m[32m                }[m
[32m+[m[32m            } else {[m
[32m+[m[32m                // Check if this is a timeout or an actual error[m
[32m+[m[32m                if (errno == EAGAIN || errno == EWOULDBLOCK) {[m
[32m+[m[32m                    // Timeout - check if we need to adjust power management[m
[32m+[m[32m                    update_power_management(false);[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    // Real error[m
[32m+[m[32m                    ESP_LOGE(TAG, "Socket error: %d", errno);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m            // Small delay instead of continuous polling[m
[32m+[m[32m            vTaskDelay(1);[m
         }[m
 [m
         if (sock != -1) {[m
[36m@@ -140,15 +266,31 @@[m [mvoid udp_handler(void *) {[m
             close(sock);[m
         }[m
     }[m
[31m-	stop_playback();[m
[32m+[m[41m    [m
[32m+[m[32m    stop_playback();[m
     vTaskDelete(NULL);[m
 }[m
 [m
 void setup_network() {[m
[31m-  xTaskCreatePinnedToCore(udp_handler, "udp_handler", 8192, NULL, 1, NULL, 1);[m
[31m-}	[m
[32m+[m[32m    // Create event group for network events[m
[32m+[m[32m    network_event_group = xEventGroupCreate();[m
[32m+[m[41m    [m
[32m+[m[32m    // Initialize power save mode[m
[32m+[m[32m    power_save_enabled = false;[m
[32m+[m[41m    [m
[32m+[m[32m    // Start in normal power mode[m
[32m+[m[32m    esp_wifi_set_ps(WIFI_PS_MIN_MODEM);[m
[32m+[m[41m    [m
[32m+[m[32m    // Start UDP handler[m
[32m+[m[32m    xTaskCreatePinnedToCore(udp_handler, "udp_handler", NETWORK_TASK_STACK_SIZE, NULL, 1, NULL, 1);[m
[32m+[m[32m}[m
 [m
 void restart_network() {[m
[31m-  if (use_tcp)[m
[31m-    connected = false;[m
[32m+[m[32m    if (use_tcp)[m
[32m+[m[32m        connected = false;[m
[32m+[m[41m    [m
[32m+[m[32m    // Reset power management state[m
[32m+[m[32m    power_save_enabled = false;[m
[32m+[m[32m    esp_wifi_set_ps(WIFI_PS_MIN_MODEM);[m
[32m+[m[32m    last_data_received_time = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
 }[m
[1mdiff --git a/main/usb_audio_player_main.c b/main/usb_audio_player_main.c[m
[1mindex 8c373f1..064741f 100644[m
[1m--- a/main/usb_audio_player_main.c[m
[1m+++ b/main/usb_audio_player_main.c[m
[36m@@ -18,6 +18,9 @@[m
 #include "nvs_flash.h"[m
 #include "driver/gpio.h"[m
 #include "global.h"[m
[32m+[m[32m#include "esp_sleep.h"[m
[32m+[m[32m#include "esp_pm.h"[m
[32m+[m[32m#include "nvs.h"[m
 #ifdef IS_USB[m
 #include "usb/usb_host.h"[m
 #include "usb/uac_host.h"[m
[36m@@ -31,7 +34,18 @@[m
 #define DEFAULT_VOLUME          45[m
 #define RTC_CNTL_OPTION1_REG 0x6000812C[m
 #define RTC_CNTL_FORCE_DOWNLOAD_BOOT 1[m
[32m+[m
[32m+[m[32m// Power management settings[m
[32m+[m[32m#define USB_CHECK_INTERVAL_US   (5 * 1000 * 1000)  // 5 seconds[m
[32m+[m[32m#define INACTIVITY_TIMEOUT_MS   (30 * 1000)        // 30 seconds[m
[32m+[m[32m#define AUDIO_IDLE_LIGHT_SLEEP_ENABLE 1[m
[32m+[m[32m#define PM_LIGHT_SLEEP_ENABLE 1[m
 bool g_neighbor_report_active = false;[m
[32m+[m[32mbool g_system_active = true;[m
[32m+[m[32mbool g_usb_connected = false;[m
[32m+[m[32muint32_t g_last_audio_activity = 0;[m
[32m+[m[32mRTC_DATA_ATTR uint8_t g_sleep_count = 0;[m
[32m+[m[32mRTC_DATA_ATTR uint32_t g_wake_interval = USB_CHECK_INTERVAL_US;[m
 typedef enum {[m
     APP_EVENT = 0,[m
     UAC_DRIVER_EVENT,[m
[36m@@ -107,17 +121,150 @@[m [mstatic void uf2_update_complete_cb()[m
     xTaskNotifyGive(main_task_hdl);[m
 }[m
 [m
[32m+[m[32m// Function to check if USB device is connected[m
[32m+[m[32mbool quick_usb_device_check(void) {[m
[32m+[m[32m    // Check for any connected USB devices[m
[32m+[m[32m    uint8_t dev_addr_list[4]; // Support up to 4 devices[m
[32m+[m[32m    int addr_count = 0;[m
[32m+[m[32m    esp_err_t err;[m
[32m+[m[41m    [m
[32m+[m[32m    // Get list of connected device addresses[m
[32m+[m[32m    err = usb_host_device_addr_list_fill(4, dev_addr_list, &addr_count);[m
[32m+[m[41m    [m
[32m+[m[32m    if (err != ESP_OK) {[m
[32m+[m[32m        ESP_LOGE(TAG, "Failed to get USB device addresses: %d", err);[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Check if we have any devices connected[m
[32m+[m[32m    if (addr_count <= 0) {[m
[32m+[m[32m        ESP_LOGI(TAG, "No USB devices detected");[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // At least one device is connected[m
[32m+[m[32m    ESP_LOGI(TAG, "Found %d USB device(s)", addr_count);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Function to enter deep sleep[m
[32m+[m[32mvoid enter_deep_sleep(void) {[m
[32m+[m[32m    ESP_LOGI(TAG, "Entering deep sleep mode");[m
[32m+[m
[32m+[m[32m    // Save any state to RTC memory if needed[m
[32m+[m[32m    g_sleep_count++;[m
[32m+[m
[32m+[m[32m    // Adjust wake interval based on sleep history (adaptive wake interval)[m
[32m+[m[32m    if (g_sleep_count > 10) {[m
[32m+[m[32m        // If we've been sleeping for a while, increase interval to save power[m
[32m+[m[32m        g_wake_interval = USB_CHECK_INTERVAL_US * 2; // 10 seconds[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g_sleep_count > 20) {[m
[32m+[m[32m        g_wake_interval = USB_CHECK_INTERVAL_US * 6; // 30 seconds[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Clean up before sleep[m
[32m+[m[32m    if (s_spk_dev_handle != NULL) {[m
[32m+[m[32m        stop_playback();[m
[32m+[m[32m        s_spk_dev_handle = NULL;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Disconnect WiFi[m
[32m+[m[32m    esp_wifi_disconnect();[m
[32m+[m[32m    esp_wifi_stop();[m
[32m+[m
[32m+[m[32m    // Configure deep sleep wake-up source (timer)[m
[32m+[m[32m    esp_sleep_enable_timer_wakeup(g_wake_interval);[m
[32m+[m[41m    [m
[32m+[m[32m    // Enter deep sleep[m
[32m+[m[32m    esp_deep_sleep_start();[m
[32m+[m[32m    // Note: execution will continue from app_main() after wake-up[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Function to prepare for light sleep[m
[32m+[m[32mvoid prepare_for_light_sleep(void) {[m
[32m+[m[32m    if (!PM_LIGHT_SLEEP_ENABLE) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    ESP_LOGI(TAG, "Preparing for light sleep");[m
[32m+[m[41m    [m
[32m+[m[32m    // Set WiFi to power save mode to reduce consumption during light sleep[m
[32m+[m[32m    esp_wifi_set_ps(WIFI_PS_MIN_MODEM);[m
[32m+[m[41m    [m
[32m+[m[32m    // Enable light sleep - if supported[m
[32m+[m[32m    esp_err_t pm_result = ESP_OK;[m
[32m+[m[41m    [m
[32m+[m[32m    #if defined(CONFIG_IDF_TARGET_ESP32)[m
[32m+[m[32m    esp_pm_config_esp32_t pm_config = {[m
[32m+[m[32m        .max_freq_mhz = 80,        // Reduced CPU frequency[m
[32m+[m[32m        .min_freq_mhz = 40,[m
[32m+[m[32m        .light_sleep_enable = true[m
[32m+[m[32m    };[m
[32m+[m[32m    pm_result = esp_pm_configure(&pm_config);[m
[32m+[m[32m    #elif defined(CONFIG_IDF_TARGET_ESP32S2)[m
[32m+[m[32m    esp_pm_config_esp32s2_t pm_config = {[m
[32m+[m[32m        .max_freq_mhz = 80,        // Reduced CPU frequency[m
[32m+[m[32m        .min_freq_mhz = 40,[m
[32m+[m[32m        .light_sleep_enable = true[m
[32m+[m[32m    };[m
[32m+[m[32m    pm_result = esp_pm_configure(&pm_config);[m
[32m+[m[32m    #elif defined(CONFIG_IDF_TARGET_ESP32S3)[m
[32m+[m[32m    esp_pm_config_esp32s3_t pm_config = {[m
[32m+[m[32m        .max_freq_mhz = 80,        // Reduced CPU frequency[m
[32m+[m[32m        .min_freq_mhz = 40,[m
[32m+[m[32m        .light_sleep_enable = true[m
[32m+[m[32m    };[m
[32m+[m[32m    pm_result = esp_pm_configure(&pm_config);[m
[32m+[m[32m    #else[m
[32m+[m[32m    pm_result = ESP_ERR_NOT_SUPPORTED;[m
[32m+[m[32m    #endif[m
[32m+[m[41m    [m
[32m+[m[32m    // Check result and handle errors gracefully[m
[32m+[m[32m    if (pm_result == ESP_OK) {[m
[32m+[m[32m        ESP_LOGI(TAG, "Light sleep enabled successfully");[m
[32m+[m[32m    } else if (pm_result == ESP_ERR_NOT_SUPPORTED) {[m
[32m+[m[32m        ESP_LOGW(TAG, "Light sleep not supported on this device or configuration");[m
[32m+[m[32m    } else {[m
[32m+[m[32m        ESP_LOGE(TAG, "Light sleep configuration failed: %d", pm_result);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
 static void uac_device_callback(uac_host_device_handle_t uac_device_handle, const uac_host_device_event_t event, void *arg)[m
 {[m
     if (event == UAC_HOST_DRIVER_EVENT_DISCONNECTED) {[m
         // stop audio player first[m
[31m-        s_spk_dev_handle = NULL;[m
[31m-        //audio_player_stop();[m
[31m-		stop_playback();[m
         ESP_LOGI(TAG, "UAC Device disconnected");[m
[31m-        ESP_ERROR_CHECK(uac_host_device_close(uac_device_handle));[m
[32m+[m[41m        [m
[32m+[m[32m        if (s_spk_dev_handle != NULL) {[m
[32m+[m[32m            stop_playback();[m
[32m+[m[32m            s_spk_dev_handle = NULL;[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Try to close the device handle[m
[32m+[m[32m        esp_err_t err = uac_host_device_close(uac_device_handle);[m
[32m+[m[32m        if (err != ESP_OK) {[m
[32m+[m[32m            ESP_LOGW(TAG, "Error closing UAC device: %d", err);[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Set usb connected flag to false[m
[32m+[m[32m        g_usb_connected = false;[m
[32m+[m[41m        [m
[32m+[m[32m        // Schedule deep sleep (with delay to allow cleanup)[m
[32m+[m[32m        // This will be processed in the main loop[m
[32m+[m[32m        TaskHandle_t main_task_hdl = xTaskGetHandle("main");[m
[32m+[m[32m        if (main_task_hdl != NULL) {[m
[32m+[m[32m            xTaskNotifyGive(main_task_hdl);[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
         return;[m
     }[m
[32m+[m[41m    [m
[32m+[m[32m    // Device is connected - update status[m
[32m+[m[32m    g_usb_connected = true;[m
[32m+[m[32m    g_last_audio_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[32m    g_sleep_count = 0; // Reset sleep counter - we're active[m
[32m+[m[41m    [m
     // Send uac device event to the event queue[m
     s_event_queue_t evt_queue = {[m
         .event_group = UAC_DEVICE_EVENT,[m
[36m@@ -154,17 +301,41 @@[m [mstatic void usb_lib_task(void *arg)[m
         .intr_flags = ESP_INTR_FLAG_LEVEL1,[m
     };[m
 [m
[31m-    ESP_ERROR_CHECK(usb_host_install(&host_config));[m
[32m+[m[32m    esp_err_t err = usb_host_install(&host_config);[m
[32m+[m[32m    if (err != ESP_OK) {[m
[32m+[m[32m        ESP_LOGE(TAG, "Failed to install USB host: %d", err);[m
[32m+[m[32m        // No USB host support, notify main task to go to sleep[m
[32m+[m[32m        g_usb_connected = false;[m
[32m+[m[32m        TaskHandle_t main_task_hdl = xTaskGetHandle("main");[m
[32m+[m[32m        if (main_task_hdl != NULL) {[m
[32m+[m[32m            xTaskNotifyGive(main_task_hdl);[m
[32m+[m[32m        }[m
[32m+[m[32m        vTaskDelete(NULL);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
     ESP_LOGI(TAG, "USB Host installed");[m
     xTaskNotifyGive(arg);[m
 [m
     while (usb_host_running) {[m
         uint32_t event_flags;[m
[31m-        usb_host_lib_handle_events(portMAX_DELAY, &event_flags);[m
[32m+[m[32m        err = usb_host_lib_handle_events(portMAX_DELAY, &event_flags);[m
[32m+[m[41m        [m
[32m+[m[32m        if (err != ESP_OK) {[m
[32m+[m[32m            ESP_LOGE(TAG, "USB host library error: %d", err);[m
[32m+[m[32m            // Handle error - might indicate device disconnection[m
[32m+[m[32m            g_usb_connected = false;[m
[32m+[m[32m            TaskHandle_t main_task_hdl = xTaskGetHandle("main");[m
[32m+[m[32m            if (main_task_hdl != NULL) {[m
[32m+[m[32m                xTaskNotifyGive(main_task_hdl);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
         // In this example, there is only one client registered[m
         // So, once we deregister the client, this call must succeed with ESP_OK[m
         if (event_flags & USB_HOST_LIB_EVENT_FLAGS_NO_CLIENTS) {[m
[31m-            ESP_ERROR_CHECK(usb_host_device_free_all());[m
[32m+[m[32m            usb_host_device_free_all();[m
             break;[m
         }[m
     }[m
[36m@@ -172,7 +343,7 @@[m [mstatic void usb_lib_task(void *arg)[m
     ESP_LOGI(TAG, "USB Host shutdown");[m
     // Clean up USB Host[m
     vTaskDelay(10); // Short delay to allow clients clean-up[m
[31m-    ESP_ERROR_CHECK(usb_host_uninstall());[m
[32m+[m[32m    usb_host_uninstall();[m
     vTaskDelete(NULL);[m
 }[m
 [m
[36m@@ -188,7 +359,20 @@[m [mstatic void uac_lib_task(void *arg)[m
         .callback_arg = NULL[m
     };[m
 [m
[31m-    ESP_ERROR_CHECK(uac_host_install(&uac_config));[m
[32m+[m[32m    // Change ESP_ERROR_CHECK to handle errors gracefully[m
[32m+[m[32m    esp_err_t err = uac_host_install(&uac_config);[m
[32m+[m[32m    if (err != ESP_OK) {[m
[32m+[m[32m        ESP_LOGE(TAG, "Failed to install UAC host: %d", err);[m
[32m+[m[32m        // Signal that we should check USB and possibly sleep[m
[32m+[m[32m        g_usb_connected = false;[m
[32m+[m[32m        TaskHandle_t main_task_hdl = xTaskGetHandle("main");[m
[32m+[m[32m        if (main_task_hdl != NULL) {[m
[32m+[m[32m            xTaskNotifyGive(main_task_hdl);[m
[32m+[m[32m        }[m
[32m+[m[32m        vTaskDelete(NULL);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
     ESP_LOGI(TAG, "UAC Class Driver installed");[m
     s_event_queue_t evt_queue = {0};[m
     while (usb_host_running) {[m
[36m@@ -209,14 +393,76 @@[m [mstatic void uac_lib_task(void *arg)[m
                         .callback = uac_device_callback,[m
                         .callback_arg = NULL,[m
                     };[m
[31m-                    ESP_ERROR_CHECK(uac_host_device_open(&dev_config, &uac_device_handle));[m
[31m-                    ESP_ERROR_CHECK(uac_host_get_device_info(uac_device_handle, &dev_info));[m
[32m+[m[41m                    [m
[32m+[m[32m                    // Open device, with improved error handling[m
[32m+[m[32m                    err = uac_host_device_open(&dev_config, &uac_device_handle);[m
[32m+[m[32m                    if (err != ESP_OK) {[m
[32m+[m[32m                        ESP_LOGE(TAG, "Failed to open UAC device: %d", err);[m
[32m+[m[32m                        // If device can't be opened, consider it disconnected[m
[32m+[m[32m                        g_usb_connected = false;[m
[32m+[m[32m                        TaskHandle_t main_task_hdl = xTaskGetHandle("main");[m
[32m+[m[32m                        if (main_task_hdl != NULL) {[m
[32m+[m[32m                            xTaskNotifyGive(main_task_hdl);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[41m                    [m
[32m+[m[32m                    // Get device info, with better error handling[m
[32m+[m[32m                    err = uac_host_get_device_info(uac_device_handle, &dev_info);[m
[32m+[m[32m                    if (err != ESP_OK) {[m
[32m+[m[32m                        ESP_LOGE(TAG, "Failed to get UAC device info: %d", err);[m
[32m+[m[32m                        // If we can't get device info, it's probably not usable[m
[32m+[m[32m                        uac_host_device_close(uac_device_handle);[m
[32m+[m[32m                        g_usb_connected = false;[m
[32m+[m[32m                        TaskHandle_t main_task_hdl = xTaskGetHandle("main");[m
[32m+[m[32m                        if (main_task_hdl != NULL) {[m
[32m+[m[32m                            xTaskNotifyGive(main_task_hdl);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[41m                    [m
                     ESP_LOGI(TAG, "UAC Device connected: SPK");[m
[32m+[m[41m                    [m
[32m+[m[32m                    // Log device parameters for debugging[m
                     uac_host_printf_device_param(uac_device_handle);[m
[31m-                    //ESP_ERROR_CHECK(uac_host_device_start(uac_device_handle, &stm_config));[m
                     s_spk_dev_handle = uac_device_handle;[m
[31m-                    start_playback(s_spk_dev_handle);[m
[31m-					//audio_player_play(s_fp);[m
[32m+[m[41m                    [m
[32m+[m[32m                    // Start playback only if we have a valid device handle[m
[32m+[m[32m                    if (s_spk_dev_handle != NULL) {[m
[32m+[m[32m                        // Try to start playback but handle errors gracefully[m
[32m+[m[32m                        err = start_playback(s_spk_dev_handle);[m
[32m+[m[32m                        if (err != ESP_OK) {[m
[32m+[m[32m                            ESP_LOGE(TAG, "Failed to start playback: %d", err);[m
[32m+[m[32m                            // Mark USB as disconnected if we can't start playback[m
[32m+[m[32m                            if (err == ESP_ERR_INVALID_ARG) {[m
[32m+[m[32m                                ESP_LOGE(TAG, "Invalid UAC device arguments, device will be treated as disconnected");[m
[32m+[m[32m                                g_usb_connected = false;[m
[32m+[m[32m                                // Close the device since we can't use it[m
[32m+[m[32m                                uac_host_device_close(uac_device_handle);[m
[32m+[m[32m                                s_spk_dev_handle = NULL;[m
[32m+[m[41m                                [m
[32m+[m[32m                                // Notify main task to check connection and possibly sleep[m
[32m+[m[32m                                TaskHandle_t main_task_hdl = xTaskGetHandle("main");[m
[32m+[m[32m                                if (main_task_hdl != NULL) {[m
[32m+[m[32m                                    xTaskNotifyGive(main_task_hdl);[m
[32m+[m[32m                                }[m
[32m+[m[32m                            } else {[m
[32m+[m[32m                                // For other errors, we'll still mark USB as connected[m
[32m+[m[32m                                // but log the issue[m
[32m+[m[32m                                ESP_LOGW(TAG, "Playback start failed but device remains connected");[m
[32m+[m[32m                                g_usb_connected = true;[m
[32m+[m[32m                                g_last_audio_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        } else {[m
[32m+[m[32m                            // Playback started successfully[m
[32m+[m[32m                            g_usb_connected = true;[m
[32m+[m[32m                            g_last_audio_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[32m                            ESP_LOGI(TAG, "Playback started successfully");[m
[32m+[m[32m                        }[m
[32m+[m[32m                    } else {[m
[32m+[m[32m                        ESP_LOGE(TAG, "No valid speaker device handle");[m
[32m+[m[32m                        g_usb_connected = false;[m
[32m+[m[32m                    }[m
                    [m
                     break;[m
                 }[m
[36m@@ -233,12 +479,17 @@[m [mstatic void uac_lib_task(void *arg)[m
                 switch (event) {[m
                 case UAC_HOST_DRIVER_EVENT_DISCONNECTED:[m
                     ESP_LOGI(TAG, "UAC Device disconnected");[m
[32m+[m[32m                    g_usb_connected = false;[m
                     break;[m
                 case UAC_HOST_DEVICE_EVENT_RX_DONE:[m
                     break;[m
                 case UAC_HOST_DEVICE_EVENT_TX_DONE:[m
[32m+[m[32m                    // Update activity timestamp for power management[m
[32m+[m[32m                    g_last_audio_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
                     break;[m
                 case UAC_HOST_DEVICE_EVENT_TRANSFER_ERROR:[m
[32m+[m[32m                    ESP_LOGW(TAG, "USB transfer error detected");[m
[32m+[m[32m                    // Don't immediately disconnect - might be temporary[m
                     break;[m
                 default:[m
                     break;[m
[36m@@ -250,7 +501,13 @@[m [mstatic void uac_lib_task(void *arg)[m
     }[m
 [m
     ESP_LOGI(TAG, "UAC Driver uninstall");[m
[31m-    ESP_ERROR_CHECK(uac_host_uninstall());[m
[32m+[m[41m    [m
[32m+[m[32m    // Clean up UAC host with error handling[m
[32m+[m[32m    err = uac_host_uninstall();[m
[32m+[m[32m    if (err != ESP_OK) {[m
[32m+[m[32m        ESP_LOGW(TAG, "Error uninstalling UAC host: %d", err);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
 	vTaskDelete(NULL);[m
 }[m
 [m
[36m@@ -453,7 +710,6 @@[m [mstatic void esp_neighbor_report_recv_handler(void* arg, esp_event_base_t event_b[m
 cleanup:[m
 	if (neighbor_list)[m
 		free(neighbor_list);[m
[31m-[m
 }[m
 [m
 static void esp_bss_rssi_low_handler(void* arg, esp_event_base_t event_base,[m
[36m@@ -461,19 +717,22 @@[m [mstatic void esp_bss_rssi_low_handler(void* arg, esp_event_base_t event_base,[m
 {[m
 	wifi_event_bss_rssi_low_t *event = event_data;[m
 [m
[31m-	//ESP_LOGI(TAG, "%s:bss rssi is=%d", __func__, event->rssi);[m
[31m-	/* Lets check channel conditions */[m
[31m-	//rrm_ctx++;[m
[31m-	if (esp_rrm_send_neighbor_report_request() < 0) {[m
[31m-		/* failed to send neighbor report request */[m
[31m-		ESP_LOGI(TAG, "failed to send neighbor report request");[m
[31m-		if (esp_wnm_send_bss_transition_mgmt_query(REASON_FRAME_LOSS, NULL, 0) < 0) {[m
[31m-			ESP_LOGI(TAG, "failed to send btm query");[m
[31m-		}[m
[31m-	} else {[m
[31m-		g_neighbor_report_active = true;[m
[31m-	}[m
[31m-[m
[32m+[m	[32m// More conservative approach to roaming - only roam if really needed[m
[32m+[m[32m    // First log the RSSI level - useful for debugging[m
[32m+[m	[32mESP_LOGD(TAG, "RSSI low event: %" PRId32 " dBm", event->rssi);[m
[32m+[m[41m    [m
[32m+[m	[32m// We only want to roam if absolutely necessary to save power[m
[32m+[m[32m    if (event->rssi < -75) {  // Only react to very low RSSI[m
[32m+[m[32m        if (esp_rrm_send_neighbor_report_request() < 0) {[m
[32m+[m[32m            /* failed to send neighbor report request */[m
[32m+[m[32m            ESP_LOGI(TAG, "failed to send neighbor report request");[m
[32m+[m[32m            if (esp_wnm_send_bss_transition_mgmt_query(REASON_FRAME_LOSS, NULL, 0) < 0) {[m
[32m+[m[32m                ESP_LOGI(TAG, "failed to send btm query");[m
[32m+[m[32m            }[m
[32m+[m[32m        } else {[m
[32m+[m[32m            g_neighbor_report_active = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
 }[m
 [m
 static void event_handler(void* arg, esp_event_base_t event_base,[m
[36m@@ -502,12 +761,20 @@[m [mstatic void event_handler(void* arg, esp_event_base_t event_base,[m
         xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);[m
 		restart_network();[m
 	} else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_CONNECTED) {[m
[31m-		ESP_LOGI(TAG, "setting rssi threshold as -58");[m
[31m-		esp_wifi_set_rssi_threshold(-58);[m
[32m+[m		[32m// Changed RSSI threshold from -58 to -70 to reduce unnecessary roaming[m
[32m+[m		[32mESP_LOGI(TAG, "Setting RSSI threshold to -70");[m
[32m+[m		[32mesp_wifi_set_rssi_threshold(-70);[m
[32m+[m[41m        [m
[32m+[m[32m        // Enable WiFi power save mode[m
[32m+[m[32m        ESP_LOGI(TAG, "Enabling WiFi power save mode");[m
[32m+[m[32m        esp_wifi_set_ps(WIFI_PS_MIN_MODEM);[m
[32m+[m[41m        [m
 		if (esp_rrm_is_rrm_supported_connection()) {[m
 			ESP_LOGI(TAG,"RRM supported");[m
[31m-                        esp_rrm_send_neighbor_report_request();[m
[31m-                        g_neighbor_report_active = true;[m
[32m+[m[32m            // Only request neighbor report if we actually need it[m
[32m+[m[32m            // (saves battery on initial connection)[m
[32m+[m[32m            // esp_rrm_send_neighbor_report_request();[m
[32m+[m[32m            // g_neighbor_report_active = true;[m
 		} else {[m
 			ESP_LOGI(TAG,"RRM not supported");[m
 		}[m
[36m@@ -516,20 +783,81 @@[m [mstatic void event_handler(void* arg, esp_event_base_t event_base,[m
 		} else {[m
 			ESP_LOGI(TAG,"BTM not supported");[m
 		}[m
[31m-[m
 	}[m
 }[m
[32m+[m
 void wifi_init_sta(void);[m
 [m
[32m+[m[32m// Function to check for audio inactivity and manage power state[m
[32m+[m[32mvoid check_activity_status(void) {[m
[32m+[m[32m    if (!g_usb_connected) {[m
[32m+[m[32m        // USB is disconnected, go to deep sleep[m
[32m+[m[32m        enter_deep_sleep();[m
[32m+[m[32m        return; // This won't actually execute due to deep sleep[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[32m    uint32_t time_since_activity = current_time - g_last_audio_activity;[m
[32m+[m[41m    [m
[32m+[m[32m    if (time_since_activity > INACTIVITY_TIMEOUT_MS && AUDIO_IDLE_LIGHT_SLEEP_ENABLE) {[m
[32m+[m[32m        // No audio activity for a while, go to light sleep if enabled[m
[32m+[m[32m        ESP_LOGI(TAG, "Audio idle for %" PRIu32 " ms, preparing for light sleep", time_since_activity);[m
[32m+[m[32m        prepare_for_light_sleep();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
 void app_main(void)[m
 {[m
[31m-	    //Initialize NVS[m
[32m+[m[32m    // Check wake-up cause[m
[32m+[m[32m    esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();[m
[32m+[m[41m    [m
[32m+[m[32m    if (wakeup_reason == ESP_SLEEP_WAKEUP_TIMER) {[m
[32m+[m[32m        // Woke up from timer - check if USB device is present[m
[32m+[m[32m        ESP_LOGI(TAG, "Woke up from deep sleep, checking USB connection");[m
[32m+[m[41m        [m
[32m+[m[32m        // Minimal initialization for USB check[m
[32m+[m[32m        // Initialize NVS[m
[32m+[m[32m        BaseType_t ret = nvs_flash_init();[m
[32m+[m[32m        if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {[m
[32m+[m[32m            ESP_ERROR_CHECK(nvs_flash_erase());[m
[32m+[m[32m            ret = nvs_flash_init();[m
[32m+[m[32m        }[m
[32m+[m[32m        ESP_ERROR_CHECK(ret);[m
[32m+[m[41m        [m
[32m+[m[32m        // Quick check for USB device[m
[32m+[m[32m        const usb_host_config_t host_config = {[m
[32m+[m[32m            .skip_phy_setup = false,[m
[32m+[m[32m            .intr_flags = ESP_INTR_FLAG_LEVEL1,[m
[32m+[m[32m        };[m
[32m+[m[41m        [m
[32m+[m[32m        ESP_ERROR_CHECK(usb_host_install(&host_config));[m
[32m+[m[32m        vTaskDelay(pdMS_TO_TICKS(100)); // Brief delay for detection[m
[32m+[m[41m        [m
[32m+[m[32m        if (!quick_usb_device_check()) {[m
[32m+[m[32m            // No USB device, go back to sleep[m
[32m+[m[32m            ESP_LOGI(TAG, "No USB device detected, returning to deep sleep");[m
[32m+[m[32m            usb_host_uninstall();[m
[32m+[m[32m            enter_deep_sleep();[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // USB device found, continue with normal initialization[m
[32m+[m[32m        ESP_LOGI(TAG, "USB device detected, initializing system");[m
[32m+[m[32m        usb_host_uninstall(); // We'll reinstall properly below[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    //Initialize NVS[m
     BaseType_t ret = nvs_flash_init();[m
     if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {[m
       ESP_ERROR_CHECK(nvs_flash_erase());[m
       ret = nvs_flash_init();[m
     }[m
     ESP_ERROR_CHECK(ret);[m
[32m+[m[41m    [m
[32m+[m[32m    // We'll skip setting the task name for now, as it's causing build issues[m
[32m+[m[32m    // but we can still find the current task with xTaskGetHandle("main") later[m
[32m+[m[32m    // TaskHandle_t currentTask = xTaskGetCurrentTaskHandle();[m
[32m+[m[32m    // vTaskSetName(currentTask, "main");[m
[32m+[m[41m    [m
 #ifdef IS_USB[m
     s_event_queue = xQueueCreate(10, sizeof(s_event_queue_t));[m
     assert(s_event_queue != NULL);[m
[36m@@ -542,16 +870,67 @@[m [mvoid app_main(void)[m
     assert(ret == pdTRUE);[m
 #endif[m
 [m
[32m+[m[32m    // Setup power management for CPU frequency scaling - if supported[m
[32m+[m[32m    ESP_LOGI(TAG, "Configuring power management...");[m
[32m+[m[32m    esp_err_t pm_result = ESP_OK;[m
[32m+[m[41m    [m
[32m+[m[32m    #if defined(CONFIG_IDF_TARGET_ESP32)[m
[32m+[m[32m    esp_pm_config_esp32_t pm_config = {[m
[32m+[m[32m        .max_freq_mhz = 240,        // Maximum frequency when active[m
[32m+[m[32m        .min_freq_mhz = 80,         // Minimum frequency to save power when idle[m
[32m+[m[32m        .light_sleep_enable = false  // Start with light sleep disabled[m
[32m+[m[32m    };[m
[32m+[m[32m    pm_result = esp_pm_configure(&pm_config);[m
[32m+[m[32m    #elif defined(CONFIG_IDF_TARGET_ESP32S2)[m
[32m+[m[32m    esp_pm_config_esp32s2_t pm_config = {[m
[32m+[m[32m        .max_freq_mhz = 240,        // Maximum frequency when active[m
[32m+[m[32m        .min_freq_mhz = 80,         // Minimum frequency to save power when idle[m
[32m+[m[32m        .light_sleep_enable = false  // Start with light sleep disabled[m
[32m+[m[32m    };[m
[32m+[m[32m    pm_result = esp_pm_configure(&pm_config);[m
[32m+[m[32m    #elif defined(CONFIG_IDF_TARGET_ESP32S3)[m
[32m+[m[32m    esp_pm_config_esp32s3_t pm_config = {[m
[32m+[m[32m        .max_freq_mhz = 240,        // Maximum frequency when active[m
[32m+[m[32m        .min_freq_mhz = 80,         // Minimum frequency to save power when idle[m
[32m+[m[32m        .light_sleep_enable = false  // Start with light sleep disabled[m
[32m+[m[32m    };[m
[32m+[m[32m    pm_result = esp_pm_configure(&pm_config);[m
[32m+[m[32m    #else[m
[32m+[m[32m    pm_result = ESP_ERR_NOT_SUPPORTED;[m
[32m+[m[32m    #endif[m
[32m+[m[41m    [m
[32m+[m[32m    // Check result and handle errors gracefully[m
[32m+[m[32m    if (pm_result == ESP_OK) {[m
[32m+[m[32m        ESP_LOGI(TAG, "Power management configured successfully");[m
[32m+[m[32m    } else if (pm_result == ESP_ERR_NOT_SUPPORTED) {[m
[32m+[m[32m        ESP_LOGW(TAG, "Power management not supported on this device or configuration");[m
[32m+[m[32m    } else {[m
[32m+[m[32m        ESP_LOGE(TAG, "Power management configuration failed: %d", pm_result);[m
[32m+[m[32m    }[m
[32m+[m
     ESP_LOGI(TAG, "ESP_WIFI_MODE_STA");[m
     wifi_init_sta();[m
[31m-	setup_buffer();[m
[31m-	setup_audio();[m
[31m-	setup_network();[m
[31m-			bool status = false;[m
[32m+[m[32m    setup_buffer();[m
[32m+[m[32m    setup_audio();[m
[32m+[m[32m    setup_network();[m
[32m+[m[41m    [m
[32m+[m[32m    g_last_audio_activity = xTaskGetTickCount() * portTICK_PERIOD_MS;[m
[32m+[m[41m    [m
     while (1) {[m
[31m-		if (!gpio_get_level(0)) {[m
[31m-		}[m
[31m-        vTaskDelay(100);[m
[32m+[m[32m        // Check for USB status and inactivity[m
[32m+[m[32m        check_activity_status();[m
[32m+[m[41m        [m
[32m+[m[32m        // Check if we received a notification that USB was disconnected[m
[32m+[m[32m        uint32_t notification_value = 0;[m
[32m+[m[32m        if (xTaskNotifyWait(0, ULONG_MAX, &notification_value, 0) == pdTRUE) {[m
[32m+[m[32m            if (!g_usb_connected) {[m
[32m+[m[32m                // USB disconnected notification received[m
[32m+[m[32m                ESP_LOGI(TAG, "USB disconnection notification received");[m
[32m+[m[32m                enter_deep_sleep();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        vTaskDelay(pdMS_TO_TICKS(1000)); // Check every second[m
     }[m
 }[m
 [m
[36m@@ -588,13 +967,16 @@[m [mvoid wifi_init_sta(void)[m
              */[m
             .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,[m
             .sae_pwe_h2e = ESP_WIFI_SAE_MODE,[m
[31m-			.sort_method = WIFI_CONNECT_AP_BY_SIGNAL,[m
[31m-			.scan_method = WIFI_ALL_CHANNEL_SCAN,[m
[31m-			.rm_enabled =1,[m
[31m-			.btm_enabled =1,[m
[31m-			.mbo_enabled =1,[m
[31m-			.pmf_cfg.capable = 1,[m
[31m-			.ft_enabled =1,[m
[32m+[m[32m            .sort_method = WIFI_CONNECT_AP_BY_SIGNAL,[m
[32m+[m[32m            // Change from all channel scan to fast scan to save power[m
[32m+[m[32m            .scan_method = WIFI_FAST_SCAN,[m
[32m+[m[32m            .rm_enabled = 1,[m
[32m+[m[32m            .btm_enabled = 1,[m
[32m+[m[32m            .mbo_enabled = 1,[m
[32m+[m[32m            .pmf_cfg.capable = 1,[m
[32m+[m[32m            .ft_enabled = 1,[m
[32m+[m[32m            // Add listen interval to reduce power during connection[m
[32m+[m[32m            .listen_interval = 3, // Listen every 3rd beacon[m
         },[m
     };[m
     ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );[m
[36m@@ -624,4 +1006,4 @@[m [mvoid wifi_init_sta(void)[m
     } else {[m
         ESP_LOGE(TAG, "UNEXPECTED EVENT");[m
     }[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m}[m
[1mdiff --git a/sdkconfig b/sdkconfig[m
[1mindex 48dd4b1..3673ea0 100644[m
[1m--- a/sdkconfig[m
[1m+++ b/sdkconfig[m
[36m@@ -356,6 +356,7 @@[m [mCONFIG_SOC_ULP_HAS_ADC=y[m
 CONFIG_SOC_PHY_COMBO_MODULE=y[m
 CONFIG_IDF_CMAKE=y[m
 CONFIG_IDF_TOOLCHAIN="gcc"[m
[32m+[m[32mCONFIG_IDF_TOOLCHAIN_GCC=y[m
 CONFIG_IDF_TARGET_ARCH_XTENSA=y[m
 CONFIG_IDF_TARGET_ARCH="xtensa"[m
 CONFIG_IDF_TARGET="esp32s3"[m
[36m@@ -512,13 +513,13 @@[m [mCONFIG_ESPTOOLPY_FLASHFREQ_80M_DEFAULT=y[m
 CONFIG_ESPTOOLPY_FLASHFREQ="80m"[m
 # CONFIG_ESPTOOLPY_FLASHSIZE_1MB is not set[m
 # CONFIG_ESPTOOLPY_FLASHSIZE_2MB is not set[m
[31m-# CONFIG_ESPTOOLPY_FLASHSIZE_4MB is not set[m
[31m-CONFIG_ESPTOOLPY_FLASHSIZE_8MB=y[m
[32m+[m[32mCONFIG_ESPTOOLPY_FLASHSIZE_4MB=y[m
[32m+[m[32m# CONFIG_ESPTOOLPY_FLASHSIZE_8MB is not set[m
 # CONFIG_ESPTOOLPY_FLASHSIZE_16MB is not set[m
 # CONFIG_ESPTOOLPY_FLASHSIZE_32MB is not set[m
 # CONFIG_ESPTOOLPY_FLASHSIZE_64MB is not set[m
 # CONFIG_ESPTOOLPY_FLASHSIZE_128MB is not set[m
[31m-CONFIG_ESPTOOLPY_FLASHSIZE="8MB"[m
[32m+[m[32mCONFIG_ESPTOOLPY_FLASHSIZE="4MB"[m
 # CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE is not set[m
 CONFIG_ESPTOOLPY_BEFORE_RESET=y[m
 # CONFIG_ESPTOOLPY_BEFORE_NORESET is not set[m
[36m@@ -532,12 +533,13 @@[m [mCONFIG_ESPTOOLPY_MONITOR_BAUD=115200[m
 #[m
 # Partition Table[m
 #[m
[31m-# CONFIG_PARTITION_TABLE_SINGLE_APP is not set[m
[32m+[m[32mCONFIG_PARTITION_TABLE_SINGLE_APP=y[m
 # CONFIG_PARTITION_TABLE_SINGLE_APP_LARGE is not set[m
 # CONFIG_PARTITION_TABLE_TWO_OTA is not set[m
[31m-CONFIG_PARTITION_TABLE_CUSTOM=y[m
[32m+[m[32m# CONFIG_PARTITION_TABLE_TWO_OTA_LARGE is not set[m
[32m+[m[32m# CONFIG_PARTITION_TABLE_CUSTOM is not set[m
 CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"[m
[31m-CONFIG_PARTITION_TABLE_FILENAME="partitions.csv"[m
[32m+[m[32mCONFIG_PARTITION_TABLE_FILENAME="partitions_singleapp.csv"[m
 CONFIG_PARTITION_TABLE_OFFSET=0x8000[m
 CONFIG_PARTITION_TABLE_MD5=y[m
 # end of Partition Table[m
[36m@@ -562,7 +564,9 @@[m [mCONFIG_COMPILER_STACK_CHECK_MODE_NONE=y[m
 # CONFIG_COMPILER_STACK_CHECK_MODE_NORM is not set[m
 # CONFIG_COMPILER_STACK_CHECK_MODE_STRONG is not set[m
 # CONFIG_COMPILER_STACK_CHECK_MODE_ALL is not set[m
[32m+[m[32m# CONFIG_COMPILER_NO_MERGE_CONSTANTS is not set[m
 # CONFIG_COMPILER_WARN_WRITE_STRINGS is not set[m
[32m+[m[32mCONFIG_COMPILER_DISABLE_DEFAULT_ERRORS=y[m
 # CONFIG_COMPILER_DISABLE_GCC12_WARNINGS is not set[m
 # CONFIG_COMPILER_DISABLE_GCC13_WARNINGS is not set[m
 # CONFIG_COMPILER_DUMP_RTL_FILES is not set[m
[36m@@ -570,6 +574,7 @@[m [mCONFIG_COMPILER_RT_LIB_GCCLIB=y[m
 CONFIG_COMPILER_RT_LIB_NAME="gcc"[m
 CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING=y[m
 # CONFIG_COMPILER_ORPHAN_SECTIONS_PLACE is not set[m
[32m+[m[32m# CONFIG_COMPILER_STATIC_ANALYZER is not set[m
 # end of Compiler options[m
 [m
 #[m
[36m@@ -917,8 +922,8 @@[m [mCONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES=4[m
 #[m
 # Sleep Config[m
 #[m
[32m+[m[32m# CONFIG_ESP_SLEEP_POWER_DOWN_FLASH is not set[m
 CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND=y[m
[31m-CONFIG_ESP_SLEEP_PSRAM_LEAKAGE_WORKAROUND=y[m
 CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU=y[m
 CONFIG_ESP_SLEEP_RTC_BUS_ISO_WORKAROUND=y[m
 CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND=y[m
[36m@@ -967,7 +972,7 @@[m [mCONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM=y[m
 #[m
 [m
 #[m
[31m-# LCD Touch Drivers are maintained in the IDF Component Registry[m
[32m+[m[32m# LCD Touch Drivers are maintained in the ESP Component Registry[m
 #[m
 [m
 #[m
[36m@@ -980,6 +985,12 @@[m [mCONFIG_LCD_PANEL_IO_FORMAT_BUF_SIZE=32[m
 # end of LCD Peripheral Configuration[m
 # end of LCD and Touch Panel[m
 [m
[32m+[m[32m#[m
[32m+[m[32m# ESP-MM: Memory Management Configurations[m
[32m+[m[32m#[m
[32m+[m[32m# CONFIG_ESP_MM_CACHE_MSYNC_C2M_CHUNKED_OPS is not set[m
[32m+[m[32m# end of ESP-MM: Memory Management Configurations[m
[32m+[m
 #[m
 # ESP NETIF Adapter[m
 #[m
[36m@@ -991,6 +1002,7 @@[m [mCONFIG_ESP_NETIF_REPORT_DATA_TRAFFIC=y[m
 # CONFIG_ESP_NETIF_RECEIVE_REPORT_ERRORS is not set[m
 # CONFIG_ESP_NETIF_L2_TAP is not set[m
 # CONFIG_ESP_NETIF_BRIDGE_EN is not set[m
[32m+[m[32m# CONFIG_ESP_NETIF_SET_DNS_PER_DEFAULT_NETIF is not set[m
 # end of ESP NETIF Adapter[m
 [m
 #[m
[36m@@ -1027,36 +1039,7 @@[m [mCONFIG_PM_RESTORE_CACHE_TAGMEM_AFTER_LIGHT_SLEEP=y[m
 #[m
 # ESP PSRAM[m
 #[m
[31m-CONFIG_SPIRAM=y[m
[31m-[m
[31m-#[m
[31m-# SPI RAM config[m
[31m-#[m
[31m-# CONFIG_SPIRAM_MODE_QUAD is not set[m
[31m-CONFIG_SPIRAM_MODE_OCT=y[m
[31m-CONFIG_SPIRAM_TYPE_AUTO=y[m
[31m-# CONFIG_SPIRAM_TYPE_ESPPSRAM64 is not set[m
[31m-CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY=y[m
[31m-CONFIG_SPIRAM_CLK_IO=30[m
[31m-CONFIG_SPIRAM_CS_IO=26[m
[31m-# CONFIG_SPIRAM_XIP_FROM_PSRAM is not set[m
[31m-# CONFIG_SPIRAM_FETCH_INSTRUCTIONS is not set[m
[31m-# CONFIG_SPIRAM_RODATA is not set[m
[31m-CONFIG_SPIRAM_SPEED_80M=y[m
[31m-# CONFIG_SPIRAM_SPEED_40M is not set[m
[31m-CONFIG_SPIRAM_SPEED=80[m
[31m-# CONFIG_SPIRAM_ECC_ENABLE is not set[m
[31m-CONFIG_SPIRAM_BOOT_INIT=y[m
[31m-CONFIG_SPIRAM_IGNORE_NOTFOUND=y[m
[31m-# CONFIG_SPIRAM_USE_MEMMAP is not set[m
[31m-# CONFIG_SPIRAM_USE_CAPS_ALLOC is not set[m
[31m-CONFIG_SPIRAM_USE_MALLOC=y[m
[31m-CONFIG_SPIRAM_MEMTEST=y[m
[31m-CONFIG_SPIRAM_MALLOC_ALWAYSINTERNAL=16384[m
[31m-# CONFIG_SPIRAM_TRY_ALLOCATE_WIFI_LWIP is not set[m
[31m-CONFIG_SPIRAM_MALLOC_RESERVE_INTERNAL=32768[m
[31m-# CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY is not set[m
[31m-# end of SPI RAM config[m
[32m+[m[32m# CONFIG_SPIRAM is not set[m
 # end of ESP PSRAM[m
 [m
 #[m
[36m@@ -1203,9 +1186,9 @@[m [mCONFIG_ESP_WIFI_ENABLED=y[m
 CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=16[m
 CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=64[m
 CONFIG_ESP_WIFI_STATIC_TX_BUFFER=y[m
[32m+[m[32m# CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER is not set[m
 CONFIG_ESP_WIFI_TX_BUFFER_TYPE=0[m
 CONFIG_ESP_WIFI_STATIC_TX_BUFFER_NUM=16[m
[31m-CONFIG_ESP_WIFI_CACHE_TX_BUFFER_NUM=32[m
 CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER=y[m
 # CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUFFER is not set[m
 CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF=0[m
[36m@@ -1215,7 +1198,6 @@[m [mCONFIG_ESP_WIFI_AMPDU_TX_ENABLED=y[m
 CONFIG_ESP_WIFI_TX_BA_WIN=6[m
 CONFIG_ESP_WIFI_AMPDU_RX_ENABLED=y[m
 CONFIG_ESP_WIFI_RX_BA_WIN=6[m
[31m-# CONFIG_ESP_WIFI_AMSDU_TX_ENABLED is not set[m
 CONFIG_ESP_WIFI_NVS_ENABLED=y[m
 CONFIG_ESP_WIFI_TASK_PINNED_TO_CORE_0=y[m
 # CONFIG_ESP_WIFI_TASK_PINNED_TO_CORE_1 is not set[m
[36m@@ -1306,7 +1288,6 @@[m [mCONFIG_FATFS_CODEPAGE=437[m
 CONFIG_FATFS_FS_LOCK=0[m
 CONFIG_FATFS_TIMEOUT_MS=10000[m
 CONFIG_FATFS_PER_FILE_CACHE=y[m
[31m-CONFIG_FATFS_ALLOC_PREFER_EXTRAM=y[m
 # CONFIG_FATFS_USE_FASTSEEK is not set[m
 CONFIG_FATFS_USE_STRFUNC_NONE=y[m
 # CONFIG_FATFS_USE_STRFUNC_WITHOUT_CRLF_CONV is not set[m
[36m@@ -1558,9 +1539,9 @@[m [mCONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY=y[m
 # CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU0 is not set[m
 # CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU1 is not set[m
 CONFIG_LWIP_TCPIP_TASK_AFFINITY=0x7FFFFFFF[m
[31m-# CONFIG_LWIP_PPP_SUPPORT is not set[m
 CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE=3[m
 CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS=5[m
[32m+[m[32m# CONFIG_LWIP_PPP_SUPPORT is not set[m
 # CONFIG_LWIP_SLIP_SUPPORT is not set[m
 [m
 #[m
[36m@@ -1593,6 +1574,7 @@[m [mCONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY=5000[m
 CONFIG_LWIP_DNS_MAX_HOST_IP=1[m
 CONFIG_LWIP_DNS_MAX_SERVERS=3[m
 # CONFIG_LWIP_FALLBACK_DNS_SERVER_SUPPORT is not set[m
[32m+[m[32m# CONFIG_LWIP_DNS_SETSERVER_WITH_NETIF is not set[m
 # end of DNS[m
 [m
 CONFIG_LWIP_BRIDGEIF_MAX_PORTS=7[m
[36m@@ -1628,7 +1610,6 @@[m [mCONFIG_LWIP_HOOK_IP6_INPUT_NONE=y[m
 # mbedTLS[m
 #[m
 CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC=y[m
[31m-# CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC is not set[m
 # CONFIG_MBEDTLS_DEFAULT_MEM_ALLOC is not set[m
 # CONFIG_MBEDTLS_CUSTOM_MEM_ALLOC is not set[m
 CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN=y[m
[36m@@ -1789,15 +1770,12 @@[m [mCONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT=y[m
 # CONFIG_NEWLIB_TIME_SYSCALL_USE_NONE is not set[m
 # end of Newlib[m
 [m
[31m-CONFIG_STDATOMIC_S32C1I_SPIRAM_WORKAROUND=y[m
[31m-[m
 #[m
 # NVS[m
 #[m
 # CONFIG_NVS_ENCRYPTION is not set[m
 # CONFIG_NVS_ASSERT_ERROR_CHECK is not set[m
 # CONFIG_NVS_LEGACY_DUP_KEYS_COMPATIBILITY is not set[m
[31m-# CONFIG_NVS_ALLOCATE_CACHE_IN_SPIRAM is not set[m
 # end of NVS[m
 [m
 #[m
[36m@@ -2008,13 +1986,20 @@[m [mCONFIG_USB_HOST_CONTROL_TRANSFER_MAX_SIZE=2048[m
 CONFIG_USB_HOST_HW_BUFFER_BIAS_PERIODIC_OUT=y[m
 [m
 #[m
[31m-# Root Hub configuration[m
[32m+[m[32m# Hub Driver Configuration[m
[32m+[m[32m#[m
[32m+[m
[32m+[m[32m#[m
[32m+[m[32m# Root Port configuration[m
 #[m
 CONFIG_USB_HOST_DEBOUNCE_DELAY_MS=250[m
 CONFIG_USB_HOST_RESET_HOLD_MS=30[m
 CONFIG_USB_HOST_RESET_RECOVERY_MS=30[m
 CONFIG_USB_HOST_SET_ADDR_RECOVERY_MS=10[m
[31m-# end of Root Hub configuration[m
[32m+[m[32m# end of Root Port configuration[m
[32m+[m
[32m+[m[32m# CONFIG_USB_HOST_HUBS_SUPPORTED is not set[m
[32m+[m[32m# end of Hub Driver Configuration[m
 [m
 # CONFIG_USB_HOST_ENABLE_ENUM_FILTER_CALLBACK is not set[m
 CONFIG_USB_OTG_SUPPORTED=y[m
[36m@@ -2114,6 +2099,7 @@[m [mCONFIG_POST_EVENTS_FROM_IRAM_ISR=y[m
 CONFIG_GDBSTUB_SUPPORT_TASKS=y[m
 CONFIG_GDBSTUB_MAX_TASKS=32[m
 # CONFIG_OTA_ALLOW_HTTP is not set[m
[32m+[m[32m# CONFIG_ESP_SYSTEM_PD_FLASH is not set[m
 CONFIG_ESP32S3_DEEP_SLEEP_WAKEUP_DELAY=2000[m
 CONFIG_ESP_SLEEP_DEEP_SLEEP_WAKEUP_DELAY=2000[m
 CONFIG_ESP32S3_RTC_CLK_SRC_INT_RC=y[m
[36m@@ -2129,9 +2115,7 @@[m [mCONFIG_ESP32_PHY_MAX_TX_POWER=20[m
 # CONFIG_ESP32_REDUCE_PHY_TX_POWER is not set[m
 CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU=y[m
 CONFIG_PM_POWER_DOWN_TAGMEM_IN_LIGHT_SLEEP=y[m
[31m-CONFIG_ESP32S3_SPIRAM_SUPPORT=y[m
[31m-CONFIG_DEFAULT_PSRAM_CLK_IO=30[m
[31m-CONFIG_DEFAULT_PSRAM_CS_IO=26[m
[32m+[m[32m# CONFIG_ESP32S3_SPIRAM_SUPPORT is not set[m
 # CONFIG_ESP32S3_DEFAULT_CPU_FREQ_80 is not set[m
 CONFIG_ESP32S3_DEFAULT_CPU_FREQ_160=y[m
 # CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240 is not set[m
[36m@@ -2174,9 +2158,9 @@[m [mCONFIG_ESP32_WIFI_ENABLED=y[m
 CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=16[m
 CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=64[m
 CONFIG_ESP32_WIFI_STATIC_TX_BUFFER=y[m
[32m+[m[32m# CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER is not set[m
 CONFIG_ESP32_WIFI_TX_BUFFER_TYPE=0[m
 CONFIG_ESP32_WIFI_STATIC_TX_BUFFER_NUM=16[m
[31m-CONFIG_ESP32_WIFI_CACHE_TX_BUFFER_NUM=32[m
 # CONFIG_ESP32_WIFI_CSI_ENABLED is not set[m
 CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED=y[m
 CONFIG_ESP32_WIFI_TX_BA_WIN=6[m
[36m@@ -2184,7 +2168,6 @@[m [mCONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y[m
 CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y[m
 CONFIG_ESP32_WIFI_RX_BA_WIN=6[m
 CONFIG_ESP32_WIFI_RX_BA_WIN=6[m
[31m-# CONFIG_ESP32_WIFI_AMSDU_TX_ENABLED is not set[m
 CONFIG_ESP32_WIFI_NVS_ENABLED=y[m
 CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0=y[m
 # CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_1 is not set[m
